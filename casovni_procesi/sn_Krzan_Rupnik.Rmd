---
title: "Seminarska naloga pri predmetu Modeliranje časovnih in prostorskih procesov"
author: "Neža Kržan, Tom Rupnik Medjedovič"
output:
  pdf_document:
    number_sections: true
    fig_caption: true
header-includes:
- \usepackage[slovene]{babel}
- \usepackage{float}
- \usepackage[T1]{fontenc}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.pos = "H", out.extra = "", fig.height = 4, fig.width = 5, fig.align = 'center', warning = F)

# install.packages("readxl")

library(readxl)
library(astsa)
library(car)
library(splines)

library(geoR)
library(gstat)
library(sp) 
library(raster) 
library(lattice)

library(kableExtra)
library(ggplot2)
library(tidyr)
library(gridExtra)
```

\newpage
\tableofcontents
\listoffigures
\listoftables
\newpage

# Uvod {-}

Seminarska naloga je sestavljena iz dveh delov. 

V prvem delu sva analizirala štiri izbrane časovne vrste, ki spadajo pod temo _Gostinstvo_. Obravnavala sva indeks prihodka za _Gostinske nastanitvene dejavnosti_ in _Dejavnost strežbe jedi in pijač_ ter prosta in zasedena delovna mesta v gostinstvu. Za vse štiri časovne vrste sva naredila podrobnejšo analizo in skušala najti model, ki najbolje napoveduje indeks prihodka v obeh dejavnostih ter prosta in zasedena delovna mesta v gostinstvu.

V drugem delu sledi analiza prostorskega procesa. Podrobneje sva obravnala vegetacijski indeks *NDRE* v mesecu juliju in izmerjene parametre, ki lahko, poleg lokacije, tudi vplivajo na vegetacijski indeks.

<!--
###############################################################################
ČASOVNI PROCES
###############################################################################
-->

# Analiza časovnih vrst

```{r message=FALSE}
# imena posameznih sheet-ov
# excel_sheets("Podatki za seminarske naloge.xlsx")

# Prosta in zasedena delovna mest
data1 = read_excel("Podatki za seminarske naloge.xlsx",
                   sheet = "Prosta in zasedena delovna mest")
# Indeks prihodka po dejavnostih
data2 = read_excel("Podatki za seminarske naloge.xlsx",
                   sheet = "Indeks prihodka po dejavnostih")

zasedena_1 = data1[,"Zasedena_1+_I GOSTINSTVO"]
prosta_1 = data1[,"Prosta_1+_I GOSTINSTVO"]

nastanitvene_dejavnosti = data2[,"Gostinske nastanitvene dejavnosti"]
strezba_jedi_pjac = data2[, "Dejavnost strežbe jedi in pijač"]
```

```{r}
# casovni interval 2010M1-2024M1
ts_nastanitve = ts(nastanitvene_dejavnosti, start = c(2010,1), frequency = 12)
ts_strezba = ts(strezba_jedi_pjac, start = c(2010,1), frequency = 12)

# preveriva ce je zadnje obdobje res 2024M1
# end(ts_nastanitve)
# end(ts_strezba)

# casovni interval 2028Q1-2023Q4
ts_zasedena = ts(zasedena_1, start = c(2008, 1), frequency = 4)
ts_prosta = ts(prosta_1, start = c(2008, 1), frequency = 4)

# preveriva ce je zadnje obdobje res 2023Q4
# end(ts_zasedena)
# end(ts_prosta)
```

## Predstavitev podatkov

Za analizo sva si izbrala podatke, ki spadajo pod temo _Gostinstvo_. 

Za indeks prihodka po dejavnosti sva si izbrala _Gostinske nastanitvene dejavnosti_ in _Dejavnost strežbe jedi in pijač_. Podatki so podani za časovno obdobje od januarja 2010 do januarja 2024(`2010M01` do `2024M01`). Frekvenca vzorčenja je približno enakomerna in enaka 12, torej gre za mesečno vzorčenje. 

Nato sva analiziral še časovni vrsti za prosta in zasedena delovna mesta v gostinstvu, kjer je zaposlena vsaj 1 oseba. Podatki so podani za časovno obdobje od leta 2008 do leta 2023(`2008Q1` do `2023Q4`) po kvartalih. Frekvenca vzorčenja je približno enakomerna in enaka 4, torej gre za četrtletno vzorčenje.

Ker sta frekvenci vzorčenja enakomerni imamo opravka z ekvidistantnimi časovnimi vrstami.

\newpage

## Časovna vrsta _Gostinske nastanitvene dejavnosti_

### Pregled časovne vrste

Podatke imamo za leta od 2010 do leta 2023 za vsak mesec v letu in za leto 2024 za mesec januar.  

Na spodnjem grafu porazdelitev indeksa prihodka glede na leta lahko vidimo, da bo proti koncu variabilnost časovne vrste zelo nekonstantna v primerjavi z ostalimi leti. Prav tako so vrednost indeksa prihodka v zadnjih letih nekoliko višji. Pri časovni vrsti na začetku pričakujemo minimalni trend, ki je sprva negativen, nato nekoliko pozitiven, potem pa sledijo velike spremembe v in po letu 2020. Glede na mesece vidimo, da je prihodkov v dejavnosti največ ravno v poletnih mesecih in pa večje je tudi v mesecu januarju in decembru, kar je dokaj logično glede na življenje ljudi.

```{r fig.height=3, fig.width=6, message=FALSE, warning=FALSE, fig.cap="Porazdelitev indeksa prihodka v gostinski nastanitveni dejavnosti glede na leta."}
df = data.frame(time = data2$...1, indeks.prihodka = data2$`Gostinske nastanitvene dejavnosti`)
df <- separate(df, time, into = c("year", "mesec"), sep = "M")

ggplot(df, aes(x= year, y= indeks.prihodka, fill=year)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("leto") + ylab("indeks prihodka")
```


```{r fig.height=3, fig.width=6, message=FALSE, warning=FALSE, fig.cap="Porazdelitev indeksa prihodka v gostinski nastanitveni dejavnosti glede na mesec."}
df = data.frame(time = data2$...1, indeks.prihodka = data2$`Gostinske nastanitvene dejavnosti`)
df <- separate(df, time, into = c("year", "mesec"), sep = "M")

ggplot(df, aes(x= mesec, y= indeks.prihodka, fill=mesec)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("mesec") + ylab("indeks prihodka")
```

Narišimo si sedaj časovno vrsto, ki jo bomo v nadaljevanju podrobneje analizirali.

```{r fig.dim=c(6,3.7), fig.cap="Časovna vrsta indeksa prihodka za 'Gostinske nastanitvene dejavnosti'."}
plot.ts(ts_nastanitve, type = "o", pch = 16, cex=0.6, xlab = "leto", ylab = "indeks prihodka", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
# gladilnik
gladilnik2 <- lowess(time(ts_nastanitve),ts_nastanitve)
points(gladilnik2$x, gladilnik2$y, type="l", col = "blue")
```

Ponovno opazimo prisotnost trenda, ki je sprva negativen, nato pa se leta 2015 obrne in postane pozitiven, naklon pa je bil v zadnjih letih največji. Dobro je vidna tudi prisotnost sezonskosti. Indeks se v vsakem letu poveča v začetku leta (januarja), nato nekoliko pade in ponovno raste do poletja (avgusta). Potem sledi padanje do konca let, ko je ponovno nekolikšno povišanje decembra. Tako gibanje je bilo tudi pričakovano, saj je to obdobje poletne in zimske sezone. 

Prav tako je dobro vidno ekstremno gibanje v času pandemije Covid-19, saj se je takrat zgodil velik padec vrednosti indeksa. Tudi amplituda nihanja se je drastično spremenila v primerjavi s predhodnjim opazovanim obdobjem, za kar je verjetno ponovno krivo obnašanje in potrebe ljudi po pandemiji in izdaja državnih bonov.

### Transformacija

```{r results='hide'}
time = 1 + frequency(ts_nastanitve) * (time(ts_nastanitve) - start(ts_nastanitve)[1])

model_nast1 = lm(ts_nastanitve~ time)
model_nast2 = lm(ts_nastanitve~ time + I(time^2))
model_nast3 = lm(ts_nastanitve~ time + I(time^2)+
                 I(sin(2 * pi/12 * time)) + I(cos(2 * pi/12 * time))+ 
                 I(sin(2 * pi/6 * time)) + I(cos(2 * pi/6 * time)))

# izbereva s kvadratnim ker boljsi
anova(model_nast1, model_nast2, model_nast3)

# Box-Cox
rez = boxCox(model_nast3, plotit = F)
(lambda = rez$x[which.max(rez$y)])

ts_nastanitve_trans = ts_nastanitve^lambda

# plot(time, ts_nastanitve, type = "o");
# points(time, model_nast3$fitted.values, type="l", col = "red")
```

Ker imamo prisotno nekonstantno varianco, s pomočjo BoxCox testa, ugotovimo, da bi bila primerna transformacija z $\lambda=$ `r lambda`. 

```{r echo=FALSE, fig.cap="Osnovna in transformirana časovna vrsta 'Gostinske nastanitvene dejavnosti'.", fig.dim=c(10,3.7)}
par(mfrow=c(1,2))
plot.ts(ts_nastanitve, type = "o", pch = 16, cex=0.6, xlab = "leto", ylab = "indeks prihodka",  xaxt="n", main="osnovna")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
# gladilnik
gladilnik <- lowess(time(ts_nastanitve),ts_nastanitve)
points(gladilnik$x, gladilnik$y, type="l", col = "blue")

plot.ts(ts_nastanitve_trans, type = "o", pch = 16, cex=0.6, xlab = "leto", ylab = "",  xaxt="n", main="transformirana")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
# gladilnik
gladilnik <- lowess(time(ts_nastanitve_trans),ts_nastanitve_trans)
points(gladilnik$x, gladilnik$y, type="l", col = "blue")
```

Ker variabilnost osnovne in transformirane časovne vrste izgleda dokaj podobna (razlikujejo se razponi na y-osi), se zaenkrat ne odločiva za transformacijo in analizo nadaljujeva z osnovno časovno vrsto.

### Avtokorelogram in parcialni avtokorelogram

Na prvem grafu je vidno, da koeficienti avtokorelacije padajo dokaj počasi, kar nakazuje, da časovna vrsta vsebuje trend, ki ga bi bilo treba modelirati z diferenciranjem. Na avtokorelogramu koeficienti avtokorelacije nakazujejo na nihanje. Sezona je vidna z nihanjem vrednosti koeficientov oz. periodičnostjo in izrazitimi vrhovi, ki se ponavljajo. Trenutno v modelu je statistično značilna korelacija med členi časovne vrste.

Tudi na parcialnem avtokorelogramu imamo nekaj koeficientov parcialne avtokorelacije, ki so statistično značilni, zato bo potrebno posvetiti nekaj pozornosti tudi temu.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram časovne vrste.", results='hide'}
acf2(ts_nastanitve, main = "", max.lag = 63)
```

### Diferenciranje 

Torej na avtokorelogramu se vidi, da koeficienti avtokorelacije nakazujejo na trend v časovni vrsti, zato jo enkrat diferenciramo in preverimo ali imamo stacionarno časovno vrsto.

```{r, fig.cap="Osnovna in diferencirana časovna vrsta.", fig.dim=c(10,3.7)}
par(mfrow=c(1,2))
plot(ts_nastanitve, main="osnovna", xlab="leto", ylab="indeks prihodka", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
plot(diff(ts_nastanitve, lag=1), main="diferenciranje 1. stopnje", xlab="leto", ylab="", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
```

Z diferenciranjem linearnega trenda smo na levi strani drugega grafa ustvarili dokaj končno variabilnost in pričakovano vrednost enako 0, v letu 2020 temu ni tako, potem pa se ponovno "uredi" časovna vrsta.

Na spodnjem avtokorelogramu opazimo, da se pojavljajo statistično značilni koeficienti avtokorelacije na odlogih 1, 2, 3, 4; torej je prisotna izrazita sezonskost.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram diferencirane časovne vrste.", results='hide'}
acf2(diff(ts_nastanitve, lag=1))
```

Zaradi zgornje ugotovitve o sezonskosti poskušajmo diferencirati še to. Na grafu vidimo, da je varianca tokrat bolj nekonstantna na desni polovici desnega grafa, kot pri diferenciranju 1. stopnje. Še vedno se vidi velik vpliv epidemije Covid-19.

```{r, fig.cap="Osnovna in diferencirana(sezonskost) časovna vrsta.", fig.dim=c(10,3.7)}
par(mfrow=c(1,2))
plot(ts_nastanitve, main="osnovna", xlab="leto", ylab="indeks prihodka", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
plot(diff(ts_nastanitve, lag=12), main="diferenciranje 12. stopnje", xlab="leto", ylab="", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
```


Če diferenciramo samo sezonskost nam avtokorelogram še vedno nakazuje prisotnost trenda, zato preverimo še, kaj se zgodi če diferenciramo trend in sezonskost.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram diferencirane(sezonskost) časovne vrste.", results='hide'}
acf2(diff(ts_nastanitve, lag=12))
```

Na spodnjem grafu vidimo dokaj konstantno varianco in pričakovano vrednost 0 do leta 2020, nato se to, zaradi epidemije Covid-19, nekoliko spremeni, kar bomo težko še bolj modelirali.

```{r, fig.cap="Diferenciranje trenda in sezonskosti v časovni vrsti.", fig.dim=c(6,3.7)}
par(mfrow=c(1,1))
plot(diff(diff(ts_nastanitve, lag=1), lag=12), main="", xlab="leto", ylab="", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
```


Vidimo, da imamo nekaj statistično značilnih koeficientov avtokorelacije in parcialne avtokorelacije, torej verjetno še vedno obstaja neka majhna avtokorelacija med podatki časovne vrste, ampak poskusimo sedaj narediti model.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram diferencirane(trend in sezonskost) časovne vrste.", results='hide'}
acf2(diff(diff(ts_nastanitve, lag=1), lag=12))
```


### Izbira ustreznega modela

Izbire modela se lotiva postopoma, zato najprej pogledava kakšne rezultate dobiva, če časovni vrsti diferencirava le trend($d=1$).

```{r fig.cap="Ostanki modela, avtokorelogram in p-vrednosti Ljung-Box testa za časovno vrsto, kjer diferenciramo trend.", fig.height=5, fig.width=6, results='hide'}
# model za diferenciranje
mod.dif <- arima(ts_nastanitve, order = c(0, 1, 0))

# diagnostika ostankov modela
sarima(ts_nastanitve, p = 0, d = 1, q = 0, details = TRUE)
```

Takoj nam je jasno, da je v časovni vrsti še vedno prisotna avtokorelacija na podlagi zgornje analize, sedaj nam Ljung-Box test to le še potrdi, saj vidimo na spodnjem grafu, da so vse p-vrednosti manjše od 0.05, torej zavračamo ničelno domnevo, da ni prisotne avtokorelacije med členi časovne vrste. Zato v model vključimo diferenciranje sezonskosti.

```{r fig.cap="Ostanki modela, avtokorelogram in p-vrednosti Ljung-Box testa za časovno vrsto, kjer diferenciramo sezonskost.", fig.height=5, fig.width=6, results='hide'}
# model za diferenciranje
mod.dif2 <- arima(ts_nastanitve, order = c(0, 0, 0),
                 seasonal = list(order = c(0, 1, 0),
                                 period = frequency(ts_nastanitve)))

# diagnostika ostankov modela
sarima(ts_nastanitve, p = 0, d = 0, q = 0,
       P=0, D=1, Q=0, S=frequency(ts_nastanitve), details = TRUE)
```

Tudi tukaj nam Ljung-Box test potrdi, da je v časovni vrsti prisoten trend, saj vidimo na spodnjem grafu, da imamo p-vrednosti manjše od 0.05, torej zavračamo ničelno domnevo, da ni prisotne avtokorelacije med členi časovne vrste. Zato v model vključimo diferenciranje trenda in sezonskosti.

```{r fig.cap="Ostanki modela, avtokorelogram in p-vrednosti Ljung-Box testa za časovno vrsto, kjer diferenciramo sezonskost.", fig.height=5, fig.width=6, results='hide'}
# model za diferenciranje
mod.dif3 <- arima(ts_nastanitve, order = c(0, 1, 0),
                 seasonal = list(order = c(0, 1, 0),
                                 period = frequency(ts_nastanitve)))

# diagnostika ostankov modela
sarima(ts_nastanitve, p = 0, d = 1, q = 0,
       P=0, D=1, Q=0, S=frequency(ts_nastanitve), details = TRUE)
```

Imamo prisotnih nekaj statistično značilnih koeficientov avtokorelacije, tudi pr Ljung-Box testu imamo še vedno p-vrednosti manjše od 0.05, torej so členi časovne vrste še vedno avtokorelirani med seboj.

Poglejmo si ponovno avtokorelogram in parcialni avtokorelogram diferencirane časovne vrste z odlogom 1 in 12. Iz ACF razberemo, da bi lahko poskusili parameter $q$ nastaviti za začetek na 4 in iz PACF, da lahko poskusimo parameter $p$ nastaviti na 4 - izberemo na podlagi statistično značilnih koeficientov. Kasneje raziskujem različne vrednosti parametrov $p$, $q$, $P$ in $Q$.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram diferencirane(trend in sezonskost) časovne vrste.", results='hide'}
acf2(diff(diff(ts_nastanitve, lag=1), lag=12))
```

```{r message=FALSE, results="hide"}
mod.sarima_nast <- arima(ts_nastanitve, order = c(4, 1, 4),
                     seasonal = list(order = c(0, 1, 0),
                                     period = frequency(ts_nastanitve)))
# AIC: 1252.806

mod.sarima_nast2 <- arima(ts_nastanitve, order = c(4, 1, 4),
                     seasonal = list(order = c(2, 1, 2),
                                     period = frequency(ts_nastanitve)))
# AIC: 1216.153

mod.sarima_nast3 <- arima(ts_nastanitve, order = c(3, 1, 3),
                     seasonal = list(order = c(2, 1, 2),
                                     period = frequency(ts_nastanitve)))
# AIC: 1218.477

mod.sarima_nast4 <- arima(ts_nastanitve, order = c(8, 1, 7),
                     seasonal = list(order = c(2, 1, 2),
                                     period = frequency(ts_nastanitve)))
#AIC: 1215.847

mod.sarima_nast5 <- arima(ts_nastanitve, order = c(8, 1, 8),
                     seasonal = list(order = c(2, 1, 2),
                                     period = frequency(ts_nastanitve)))
#AIC: 1217.424

mod.sarima_nast6 <- arima(ts_nastanitve, order = c(8, 1, 7),
                     seasonal = list(order = c(2, 1, 1),
                                     period = frequency(ts_nastanitve)))
#AIC: 1221.499

mod.sarima_nast7 <- arima(ts_nastanitve, order = c(8, 1, 7),
                     seasonal = list(order = c(1, 1, 2),
                                     period = frequency(ts_nastanitve)))
# AIC: 1212.329
```

```{r message=FALSE, results=T}
aic = data.frame(indeks = c(1,2,3,4,5,6,7), 
                 model = c("SARIMA(4, 1, 4, 0, 1, 0)", 
                           "SARIMA(4, 1, 4, 2, 1, 2)",
                           "SARIMA(3, 1, 3, 2, 1, 2)", 
                           "SARIMA(8, 1, 7, 2, 1, 2)", 
                           "SARIMA(8, 1, 8, 2, 1, 2)",
                           "SARIMA(8, 1, 7, 2, 1, 1)", 
                           "SARIMA(8, 1, 7, 1, 1, 2)"),
                 AIC = c(mod.sarima_nast$aic, mod.sarima_nast2$aic,
                         mod.sarima_nast3$aic, mod.sarima_nast4$aic,
                         mod.sarima_nast5$aic, mod.sarima_nast6$aic,
                         mod.sarima_nast7$aic))

kable(aic, caption = "SARIMA modeli in pripadajoče AIC vrednosti.",
             format="markdown")
```

```{r results='hide'}
# H0: avtokorelacijski koeficienti (ACF) časovne vrste enake nič
box = Box.test(mod.sarima_nast7$res, lag = 48, type = c("Ljung-Box"),
               fitdf = mod.sarima_nast7$arma[1] + mod.sarima_nast7$arma[2] +
           mod.sarima_nast7$arma[3] + mod.sarima_nast7$arma[4])
```


Na podlagi Akaikijevega informacijskega kriterija(AIC) se odločiva za model **SARIMA(8, 1, 7, 1, 1, 2)**. Tudi na spodnjih grafih diagnostike ostankov modela vidimo, da sva se z izbranimi parametri nekoliko bolj približala idealu. p-vrednost Ljung-Box testa kaže na statistično neznačilen rezultat (p-vrednost = 0.477), zato ničelne domneve ne moremo zavrniti.

```{r fig.cap="Ostanki modela, avtokorelogram in p-vrednosti Ljung-Box testa za časovno vrsto, kjer diferenciramo sezonskost.", fig.height=5, fig.width=6, results='hide'}
# diagnostika ostankov modela
sarima(ts_nastanitve, p = 8, d = 1, q = 7, P=1, D=1, Q=2,
       S=frequency(ts_nastanitve), details = TRUE)
```

### Napoved

S pomočjo zgornjega modela bova sedaj poskušala napovedati indeks prihodka  za nekaj let vnaprej. Ker naju zanima kako dober je najin model, na začetku ponovno podatke razdeliva na testne in učne. Najbolj naju zanima kako bo napovedoval po letu 2020, če tega leta nima v učnih podatkih in kako napoveduje, če ga vključiva v učne podatke in napovedujeva samo za mesec januar v letu 2024.

```{r results=F, fig.cap="Časovna vrsta in napovedi na podlagi modela od leta 2020 naprej.", fig.width=6, fig.height=4}
indeks.prihodka <- window(ts_nastanitve, start = c(2010, 1), end = c(2019, 12))
test <- window(ts_nastanitve, start = c(2020, 1), end = c(2024, 1))

sarima.for(indeks.prihodka, n.ahead = 12*4, p = 8, d = 1, q = 7, P=1, D=1, Q=2, S=12, plot.all = TRUE)
points(test, type = "o")
```

Model prevzame naraščajoč trend in ga predpostavi tudi napovedim. Pričakovano je bilo, da za leto 2020 model ne bo napovedal ustrezno, potem pa za kasnejša leta napovedi tudi niso najboljše, so nižje kot realne, torej model nekoliko podcenjuje indeks prihodka. Tudi intervali zaupanja niso ekstremno široki. Zaenkart bi sicer rekli, da je napoved nekoliko neinformativna.


Poglejmo si sedaj še, kakšne so napovedi, če v učno množico vključimo podatke iz leta 2020 do sredine leta 2023.

```{r results=F, fig.cap="Časovna vrsta in napovedi na podlagi modela od sredine leta 2023 naprej.", fig.width=6, fig.height=4}
indeks.prihodka <- window(ts_nastanitve, start = c(2010, 1), end = c(2023, 6))
test <- window(ts_nastanitve, start = c(2023, 7), end = c(2024, 1))

sarima.for(indeks.prihodka, n.ahead = 8, p = 8, d = 1, q = 7, P=1, D=1, Q=2, S=12, plot.all = TRUE)
points(test, type = "o")
```

Tokrat pa vidimo, da napovedane vrednosti niso tako zelo slabe, model določene napovedi skoraj zadane z realnimi indeksi prihodka, interval zaupanja sicer še vedno ni pretirano ozek. Torej s tega bi lahko sklepala, da je najin model dober za napovedovanje vrednosti indeksa prihodka za kratke časovne intervale naprej.

\newpage

## Časovna vrsta _Dejavnost strežbe jedi in pijač_

### Pregled časovne vrste

Podatke imamo za leta od 2010 do leta 2023 za vsak mesec v letu in za leto 2024 za mesec januar.  

Na spodnjem grafu porazdelitev indeksa prihodka glede na leta lahko vidimo, da bo proti koncu variabilnost časovne vrste spet zelo nekonstantna v primerjavi z ostalimi leti. Pri časovni vrsti na začetku pričakujemo naraščajoč trend in potem velike spremembe v in po letu 2020. Glede na mesece vidimo, da je prihodkov v dejavnosti največ ravno v poletnih mesecih in pa večje je tudi v mesecu decembru, kar je dokaj logično glede na življenje ljudi.

```{r fig.height=3, fig.width=6, message=FALSE, warning=FALSE, fig.cap="Porazdelitev indeksa prihodka v dejavnosti strežbe jedi in pijač glede na leta."}
df = data.frame(time = data2$...1, indeks.prihodka = data2$`Dejavnost strežbe jedi in pijač`)
df <- separate(df, time, into = c("year", "mesec"), sep = "M")

ggplot(df, aes(x= year, y= indeks.prihodka, fill=year)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("leto") + ylab("indeks prihodka")
```

```{r fig.height=3, fig.width=6, message=FALSE, warning=FALSE, fig.cap="Porazdelitev indeksa prihodka v dejavnosti strežbe jedi in pijač glede na mesec."}
df = data.frame(time = data2$...1, indeks.prihodka = data2$`Dejavnost strežbe jedi in pijač`)
df <- separate(df, time, into = c("year", "mesec"), sep = "M")

ggplot(df, aes(x= mesec, y= indeks.prihodka, fill=mesec)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("mesec") + ylab("indeks prihodka")
```

Narišimo si sedaj časovno vrsto, ki jo bomo v nadaljevanju podrobneje analizirali.

```{r fig.dim=c(6,3.7), fig.cap="Časovna vrsta indeksa prihodka za 'Dejavnost strežbe jedi in pijač'."}
plot.ts(ts_strezba, type = "o", pch = 16, cex=0.6, xlab = "leto", ylab = "indeks prihodka", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
# gladilnik
gladilnik2 <- lowess(time(ts_strezba),ts_strezba)
points(gladilnik2$x, gladilnik2$y, type="l", col = "blue")
```

Ponovno opazimo prisotnost trenda, ki je čez celotno obdobje naraščajoče, naklon pa je bil največji med letoma 2015 in 2018. Sprva bi glede na vzorec spreminjanja (nihanja) indeksa lahko rekli, da je prisotna sezonskost. Če natančneje pogledamo sta v posameznem letu ekstremni vrednosti poleti in meseca decembra. Do leta 2018 je bila najvišja vrednost indeksa v posameznem letu dosežena decembra, nato pa je bila višja vrednost dosežena poleti. Iz tega bi lahko rekli, da je nekoliko prisotno ciklično nihanje, vendar ni enako čez celotno opazovano obdobje. 

Prav tako je dobro vidno ekstremno gibanje v času pandemije Covid-19, saj se je takrat zgodil velik padec vrednosti indeksa. Tudi amplituda nihanja se je drastično spremenila v primerjavi s predhodnjim opazovanim obdobjem, za kar je verjetno ponovno krivo obnašanje in potrebe ljudi po pandemiji in izdaja državnih bonov.

### Transformacija

```{r results='hide'}
time = 1 + frequency(ts_strezba) * (time(ts_strezba) - start(ts_strezba)[1])

model_str1 = lm(ts_strezba~ time)
model_str2 = lm(ts_strezba~ time + I(time^2))
model_str3 = lm(ts_strezba~ time + I(time^2) + I(time^3))

# izbereva s kvadratnim ker boljsi
anova(model_str1, model_str2, model_str3)

# Box-Cox
rez = boxCox(model_str3, plotit = F)
(lambda = rez$x[which.max(rez$y)])

ts_strezba_trans = ts_strezba^lambda
```

Ker imamo priostno nekonstantno varianco, s pomočjo BoxCox testa, ugotovimo, da bi bila primerna transformacija z $\lambda=$ `r lambda`. 

```{r echo=FALSE, fig.cap="Osnovna in transformirana časovna vrsta 'Dejavnost strežbe jedi in pijač'.", fig.dim=c(10,3.7)}
par(mfrow=c(1,2))
plot.ts(ts_strezba, type = "o", pch = 16, cex=0.6, xlab = "leto", ylab = "indeks prihodka",  xaxt="n", main="osnovna")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
# gladilnik
gladilnik <- lowess(time(ts_strezba),ts_strezba)
points(gladilnik$x, gladilnik$y, type="l", col = "blue")

plot.ts(ts_strezba_trans, type = "o", pch = 16, cex=0.6, xlab = "leto", ylab = "",  xaxt="n", main="transformirana")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
# gladilnik
gladilnik <- lowess(time(ts_strezba_trans),ts_strezba_trans)
points(gladilnik$x, gladilnik$y, type="l", col = "blue")
```

Ker variabilnost osnovne in transformirane časovne vrste izgleda dokaj podobna, se zaenkrat ne odločiva za transformacijo in analizo nadaljujeva z osnovno časovno vrsto.

### Avtokorelogram in parcialni avtokorelogram

Na prvem grafu je vidno, da koeficienti avtokorelacije padajo dokaj počasi, kar nakazuje, da časovna vrsta vsebuje trend, ki ga bi bilo treba modelirati z diferenciranjem. Na avtokorelogramu koeficienti avtokorelacije nakazujejo na nihanje, sicer šele pri kasnejših odlogih in tudi težko ocenimo ali gre za počasno padanje ali ne, ampak vseeno to vzamemo v razmislek za vključitev modeliranja sezonskosti, ki se na osnovnem grafu časovne vrste ni videla. Trenutno v modelu je statistično značilna korelacija med členi časovne vrste.

Parcialni avtokorelogram ne prikazuje posebnosti, imamo nekaj koeficientov parcialne avtokorelacije, ki so statistično značilni, ampak se pojavljajo šele pri večjih odlogih, zato temu pred modeliranjem trenda, ne bova posvečala večje pozornosti.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram časovne vrste.", results='hide'}
acf2(ts_strezba, main = "", max.lag = 63)
```

### Diferenciranje 

Torej vidi se na avtokorelogramu, da koeficienti avtokorelacije nakazujejo na trend v časovni vrsti, zato jo enkrat diferenciramo in poskušamo dobiti stacionarno časovno vrsto.

```{r, fig.cap="Osnovna in diferencirana časovna vrsta.", fig.dim=c(10,3.7)}
par(mfrow=c(1,2))
plot(ts_strezba, main="osnovna", xlab="leto", ylab="indeks prihodka", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
plot(diff(ts_strezba, lag=1), main="diferenciranje 1. stopnje", xlab="leto", ylab="", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
```

Z diferenciranjem linearnega trenda smo na levi strani drugega grafa ustvarili dokaj končno variabilnost in pričakovano vrednost enako 0, v letu 2020 temu ni tako, potem pa se ponovno "uredi" časovna vrsta.

Na spodnjem avtokorelogramu opazimo, da se pojavljajo statistično značilni koeficienti avtokorelacije na odlogih 1, 2, 3, 4; torej se nama zdi, da je prisotna neka sezonskost.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram diferencirane časovne vrste.", results='hide'}
acf2(diff(ts_strezba, lag=1))
```

Zaradi zgornje ugotovitve o sezonskosti poskušajmo diferencirati še to. Na grafu vidimo, da je varianca tokrat bolj nekonstantna na levi strani levega grafa in tudi skrajno desno na levem grafu, kot pri diferenciranju 1. stopnje. Še vedno se vidi velik vpliv epidemije Covid-19.

```{r, fig.cap="Osnovna in diferencirana(sezonskost) časovna vrsta.", fig.dim=c(10,3.7)}
par(mfrow=c(1,2))
plot(ts_strezba, main="osnovna", xlab="leto", ylab="indeks prihodka", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
plot(diff(ts_strezba, lag=12), main="diferenciranje 12. stopnje", xlab="leto", ylab="", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
```

Če diferenciramo samo sezonskost nam avtokorelogram še vedno nakazuje prisotnost trenda, zato preverimo še, kaj se zgodi če diferenciramo trend in sezonskost.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram diferencirane(sezonskost) časovne vrste.", results='hide'}
acf2(diff(ts_strezba, lag=12))
```

Na spodnjem grafu vidimo dokaj konstantno varianco in pričakovano vrednost 0 do leta 2020, nato se to, zaradi epidemije Covid-19, nekoliko spremeni, kar bomo težko še bolj modelirali.

```{r, fig.cap="Diferenciranje trenda in sezonskosti v časovni vrsti.", fig.dim=c(6,3.7)}
par(mfrow=c(1,1))
plot(diff(diff(ts_strezba, lag=1), lag=12), main="", xlab="leto", ylab="", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
```

Vidimo, da imamo nekaj statistično značilnih koeficientov avtokorelacije in parcialne avtokorelacije, torej verjetno še vedno obstaja neka majhna avtokorelacija med podatki časovne vrste, ampak poskusimo sedaj narediti model.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram diferencirane(trend in sezonskost) časovne vrste.", results='hide'}
acf2(diff(diff(ts_strezba, lag=1), lag=12))
```

### Izbira ustreznega modela

Izbire modela se lotiva postopoma, zato najprej pogledava kakšne rezultate dobiva, če časovni vrsti diferencirava le trend($d=1$).

```{r fig.cap="Ostanki modela, avtokorelogram in p-vrednosti Ljung-Box testa za časovno vrsto, kjer diferenciramo trend.", fig.height=5, fig.width=6, results='hide'}
# model za diferenciranje
mod.dif <- arima(ts_strezba, order = c(0, 1, 0))

# diagnostika ostankov modela
sarima(ts_strezba, p = 0, d = 1, q = 0, details = TRUE)
```

Takoj nam je jasno, da je v časovni vrsti še vedno prisotna avtokorelacija na podlagi zgornje analize, sedaj nam Ljung-Box test to le še potrdi, saj vidimo na spodnjem grafu, da je večina p-vrednosti manjših od 0.05, torej zavračamo ničelno domnevo, da ni prisotne avtokorelacije med členi časovne vrste. Zato v model vključimo diferenciranje sezonskosti.

```{r fig.cap="Ostanki modela, avtokorelogram in p-vrednosti Ljung-Box testa za časovno vrsto, kjer diferenciramo sezonskost.", fig.height=5, fig.width=6, results='hide'}
# model za diferenciranje
mod.dif2 <- arima(ts_strezba, order = c(0, 0, 0),
                 seasonal = list(order = c(0, 1, 0), period = frequency(ts_strezba)))

# diagnostika ostankov modela
sarima(ts_strezba, p = 0, d = 0, q = 0, P=0, D=1, Q=0, S=frequency(ts_strezba), details = TRUE)
```

Tudi tukaj nam nam Ljung-Box test potrdi, da je v časovn vrsti prisoten trend, saj vidimo na spodnjem grafu, da imamo p-vrednosti manjše od 0.05, torej zavračamo ničelno domnevo, da ni prisotne avtokorelacije med členi časovne vrste. Zato v model vključimo diferenciranje trenda in sezonskosti.

```{r fig.cap="Ostanki modela, avtokorelogram in p-vrednosti Ljung-Box testa za časovno vrsto, kjer diferenciramo sezonskost.", fig.height=5, fig.width=6, results='hide'}
# model za diferenciranje
mod.dif3 <- arima(ts_strezba, order = c(0, 1, 0),
                 seasonal = list(order = c(0, 1, 0), period = frequency(ts_strezba)))

# diagnostika ostankov modela
sarima(ts_strezba, p = 0, d = 1, q = 0, P=0, D=1, Q=0, S=frequency(ts_strezba), details = TRUE)
```

Imamo prisotnih nekaj statistično značilnih koeficientov avtokorelacije, tudi pr Ljung-Box testu imamo še vedno p-vrednosti manjše od 0.05, torej so členi časovne vrste še vedno avtokorelirani med seboj.

Poglejmo si ponovno avtokorelogram in parcialni avtokorelogram diferencirane časovne vrste z odlogom 1 in 12. Iz ACF razberemo, da bi lahko poskusili parameter $q$ nastaviti za začetek na 8 in iz PACF, da lahko poskusimo parameter $p$ nastaviti na 6 <!-- Tom: tukej je vrejtno p=5--> - izberemo na podlagi statistično značilnih koeficientov. Kasneje raziskujem različne vrednosti parametrov $p$, $q$, $P$ in $Q$.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram diferencirane(trend in sezonskost) časovne vrste.", results='hide'}
acf2(diff(diff(ts_strezba, lag=1), lag=12))
```

```{r message=FALSE, results="hide"}
mod.sarima_str <- arima(ts_strezba, order = c(8, 1, 6),
                     seasonal = list(order = c(0, 1, 0),
                                     period = frequency(ts_strezba)))
# AIC: 1234.608

mod.sarima_str2 <- arima(ts_strezba, order = c(8, 1, 6),
                     seasonal = list(order = c(2, 1, 1),
                                     period = frequency(ts_strezba)))
# AIC: 1209.009

mod.sarima_str3 <- arima(ts_strezba, order = c(7, 1, 6),
                     seasonal = list(order = c(2, 1, 2),
                                     period = frequency(ts_strezba)))
# AIC: 1204.863

mod.sarima_str4 <- arima(ts_strezba, order = c(7, 1, 5),
                     seasonal = list(order = c(2, 1, 2),
                                     period = frequency(ts_strezba)))
#AIC: 1209.447

mod.sarima_str5 <- arima(ts_strezba, order = c(5, 1, 6),
                     seasonal = list(order = c(2, 1, 2),
                                     period = frequency(ts_strezba)))
#AIC: 1200.246

mod.sarima_str6 <- arima(ts_strezba, order = c(5, 1, 6),
                     seasonal = list(order = c(2, 1, 1),
                                     period = frequency(ts_strezba)))
#AIC: 1209.481

mod.sarima_str7 <- arima(ts_strezba, order = c(5, 1, 8),
                     seasonal = list(order = c(2, 1, 2),
                                     period = frequency(ts_strezba)))
# AIC: 1203.572

mod.sarima_str8 <- arima(ts_strezba, order = c(3, 1, 6),
                     seasonal = list(order = c(2, 1, 2),
                                     period = frequency(ts_strezba)))
#AIC: 1208.608

mod.sarima_str9 <- arima(ts_strezba, order = c(5, 1, 6),
                     seasonal = list(order = c(3, 1, 1),
                                     period = frequency(ts_strezba)))
#AIC: 1211.117
```
```{r message=FALSE, results=T}
aic = data.frame(indeks = c(1,2,3,4,5,6,7,8,9), 
                 model = c("SARIMA(8, 1, 6, 0, 1, 0)", "SARIMA(8, 1, 6, 2, 1, 1)",
                           "SARIMA(7, 1, 6, 2, 1, 2)", "SARIMA(7, 1, 5, 2, 1, 2)", 
                           "SARIMA(5, 1, 6, 2, 1, 2)",
                           "SARIMA(5, 1, 6, 2, 1, 1)", "SARIMA(5, 1, 8, 2, 1, 2)", 
                           "SARIMA(3, 1, 6, 2, 1, 2)",
                           "SARIMA(5, 1, 6, 3, 1, 1)"),
                 AIC = c(mod.sarima_str$aic, mod.sarima_str2$aic, mod.sarima_str3$aic,
                         mod.sarima_str4$aic, mod.sarima_str5$aic, mod.sarima_str6$aic,
                         mod.sarima_str7$aic, mod.sarima_str8$aic, mod.sarima_str9$aic))

kable(aic, caption = "SARIMA modeli in pripadajoče AIC vrednosti.",
             format="markdown")
```


<!--Tom28: fitdf bi vrjetno mogu bit 
fitdf = mod.sarima_nast7$arma[1] + mod.sarima_nast7$arma[2] +
           mod.sarima_nast7$arma[3] + mod.sarima_nast7$arma[4]
ker je enak p+q+P+Q
oz vsaj tko smo mi na predavanjih
pa lag smo imeli 60 oz 48
-->

```{r results='hide'}
# H0: avtokorelacijski koeficienti (ACF) časovne vrste enake nič
box = Box.test(mod.sarima_str5$res, lag = 20, type = c("Ljung-Box"), fitdf = 2)
```

Na podlagi Akaikijevega informacijskega kriterija(AIC) se odločiva za model **SARIMA(5, 1, 6, 2, 1, 2)**. Tudi na spodnjih grafih diagnostike ostankov modela vidimo, da sva se z izbranimi parametri nekoliko bolj približala idealu. p-vrednost Ljung-Box testa pa je tudi ravno na meji(p-vrednost = 0.512), zato bi lahko zavrnili ničelno domnevo.

```{r fig.cap="Ostanki modela, avtokorelogram in p-vrednosti Ljung-Box testa za časovno vrsto, kjer diferenciramo sezonskost.", fig.height=5, fig.width=6, results='hide'}
# diagnostika ostankov modela
sarima(ts_strezba, p = 5, d = 1, q = 6, P=2, D=1, Q=2, S=frequency(ts_strezba), details = TRUE)
```

### Napoved

S pomočjo zgornjega modela bova sedaj poskušača napovedati indeks prihodka  za nekaj let vnaprej. Ker naju zanima kako dober je najin model, na začetku ponovno podatke razdeliva na testne in učne. Najbolj naju zanima kako bo napovedoval po letu 2020, če tega leta nima v učnih podatkih in kako napoveduje, če ga vključiva v učne podatke in napovedujeva samo za mesec januar v letu 2024.

```{r results=F, fig.cap="Časovna vrsta in napovedi na podlagi modela od leta 2020 naprej.", fig.width=6, fig.height=4}
indeks.prihodka <- window(ts_strezba, start = c(2010, 1), end = c(2019, 4))
test <- window(ts_strezba, start = c(2020, 1), end = c(2024, 1))

sarima.for(indeks.prihodka, n.ahead = 12*4, p = 5, d = 1, q = 6, P=2, D=1, Q=2, S=12, plot.all = TRUE)
points(test, type = "o")
```

Model prevzame naraščajoč trend in ga predpostavi tudi napovedim. Pričakovano je bilo, da za leto 2020 model ne bo napovedal ustrezno, potem pa za kasnejša leta napovedi niso tako zelo slabe, so nekoliko višje kot realne, torej model nekoliko precenjuje indkes prihodka. Tudi intervali zaupanja niso ekstremno široki. Zaenkart bi sicer rekli, da je napoved nekoliko neinformativna.

Poglejmo si sedaj še, kakšne so napovedi, če v učno množico vključimo podatke iz leta 2020 do sredine leta 2023.

```{r results=F, fig.cap="Časovna vrsta in napovedi na podlagi modela od sredine leta 2023 naprej.", fig.width=6, fig.height=4}
indeks.prihodka <- window(ts_strezba, start = c(2010, 1), end = c(2023, 6))
test <- window(ts_strezba, start = c(2023, 7), end = c(2024, 2))

sarima.for(indeks.prihodka, n.ahead = 8, p = 5, d = 1, q = 6, P=2, D=1, Q=2, S=12, plot.all = TRUE)
points(test, type = "o")
```

Tokrat pa vidimo, da napovedane vrednosti niso tako zelo slabe, model določene napovedi skoraj zadane z realnimi indeksi prihodka, interval zaupanja sicer še vedno ni pretirano ozek. Torej s tega bi lahko sklepala, da je najin model dober za napovedovanje vrednosti indeksa prihodka za kratke časovne intervale naprej.

\newpage

## Časovna vrsta _Gostinstvo prosta delovna mesta 1+_

### Pregled časovne vrste

Podatke imamo za leta od 2008 do leta 2023 za vsako kvartalno obdobje.

Na spodnjem grafu porazdelitve prostih delovnih mest v gostinstvu glede na leta lahko vidimo, da bo proti koncu variabilnost časovne vrste zelo nekonstantna v primerjavi z ostalimi leti. Pri časovni vrsti na začetku pričakujemo naraščajoč trend in potem velike spremembe v letu 2020. Glede na kvartal pa je porazdelitev dokaj enaka, malenkost odstopa morda le drugo kvartalno obodbje.

```{r fig.height=3, fig.width=6, message=FALSE, warning=FALSE, fig.cap="Porazdelitev prostih delovnih v gostinstvu, kjer je zaposlena vsaj 1 oseba, glede na leto."}
df = data.frame(time = data1$...1, prosta = data1$`Prosta_1+_I GOSTINSTVO`)
df <- separate(df, time, into = c("year", "Q"), sep = "Q")

ggplot(df, aes(x= year, y= prosta, fill=year)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("leto") + ylab("stevilo prostih delovnih mest")
```

```{r fig.height=3, fig.width=6, message=FALSE, warning=FALSE, fig.cap="Porazdelitev prostih delovnih v gostinstvu, kjer je zaposlena vsaj 1 oseba, glede na kvartal."}
ggplot(df, aes(x= Q, y= prosta, fill=Q)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("kvartal v letu") + ylab("stevilo prostih delovnih mest")
```


Narišimo si sedaj časovno vrsto, ki jo bomo v nadaljevanju podrobneje analizirali.

```{r echo=FALSE, fig.cap="Časovna vrsta 'Gostinstvo prosta delovna mesta 1+'.", fig.dim=c(6,3.7)}
plot.ts(ts_prosta, type = "o", pch = 16, cex=0.6, xlab = "leto", ylab = "stevilo delovnih mest",  xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))

# gladilnik
gladilnik <- lowess(time(ts_prosta),ts_prosta)
points(gladilnik$x, gladilnik$y, type="l", col = "blue")
```

Kot sva omenila že zgoraj je iz grafa časovne vrste možno opaziti prisotnost trenda. Ta čez celotno opazovano obdobje narašča. Sprva nekoliko bolj položno, po letu 2013 pa se naklon poveča. Sezonskosti ni mogoče zaznati, saj so lokalni ekstremi bolj naključni, kot da bi se ponavljali v ciklu. 

Vidno pa je ekstremno obdobje (čas pandemije Covid-19) in to ravno proti koncu časovne vrste. To obdobje bo verjetno povzročalo težave pri iskanju ustreznega modela za napovedovanje prihodnjih prostih delovnih mest v gostinstvu, kjer je zaposlena 1 oseba. Če bi podate razdelili na učno in testno množico in v testno množico vzamemo zadnja 3 leta v naših podatkih, napovedi modela zagotovo ne bodo pravilne, saj se bo model učil na razmeroma normalnih in predvidljivih podatkih. 

### Transformacija časovne vrste

S pomočjo BoxCox testa, ugotovimo, da je primerno časovno vrsto transformirati in se s tem morda poskušamo malenkost znebiti nekonstantne variance. Primerna je logaritemska transformacija.

```{r results=F}
time = 1 + frequency(ts_prosta) * (time(ts_prosta) - start(ts_prosta)[1])

model_prosta1 = lm(ts_prosta~ time)
model_prosta2 = lm(ts_prosta~ time + I(time^2))
model_prosta3 = lm(ts_prosta~ time + I(time^2) + I(time^3))
model_prosta4 = lm(ts_prosta~ ns(time, df = 8))

anova(model_prosta1, model_prosta2, model_prosta3, model_prosta4)

# Box-Cox za 'Gostinstvo prosta delovna mesta 1+'.
rez = boxCox(model_prosta4, plotit = F)
lambda = rez$x[which.max(rez$y)]
# Lambda = 0 --> log transformacija
ts_prosta_log = log(ts_prosta) 
```

```{r echo=FALSE, fig.cap="Osnovna in logaritmirana časovna vrsta 'Gostinstvo prosta delovna mesta 1+'.", fig.dim=c(10,3.7)}
par(mfrow=c(1,2))
plot.ts(ts_prosta, type = "o", pch = 16, cex=0.6, xlab = "leto", ylab = "stevilo delovnih mest",  xaxt="n", main="osnovna")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
# gladilnik
gladilnik <- lowess(time(ts_prosta),ts_prosta)
points(gladilnik$x, gladilnik$y, type="l", col = "blue")

plot.ts(ts_prosta_log, type = "o", pch = 16, cex=0.6, xlab = "leto", ylab = "",  xaxt="n", main="transformirana")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
# gladilnik
gladilnik <- lowess(time(ts_prosta_log),ts_prosta_log)
points(gladilnik$x, gladilnik$y, type="l", col = "blue")
```

Krivulji osnovne in transponirane časovne vrste sta si dokaj podobni, ampak nadaljujmo analizo z transformirano časovno vrsto.

### Avtokorelogram in parcialni avtokorelogram

Na prvem grafu je vidno, da koeficienti avtokorelacije počasi padajo, torej časovna vrsta vsebuje trend, ki ga bi bilo treba modelirati. Sprva je bil narisan osnovni avtokorelogram, s katerega se je videlo, da če bi povečali odloge(_Lag_), bi morda bilo videti nihanje. Na spodnjem avtokorelogramu imamo povečane odloge in koeficienti avtokorelacije morda nakazujejo na zelo počasno nihanje.

Parcialni avtokorelogram ne prikazuje posebnosti, imamo samo en koeficient parcialne avtokorelacije statistično značilen, zato sklepava, da bomo v modelu imeli red avtoregresijskega modela enak 1 ali pa celo 0.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram logaritmirane časovne vrste.", results='hide'}
acf2(ts_prosta_log, main = "", max.lag = 63)
```

Poglejmo si še avtokorelogram in parcialni avtokorelogram osnovne časovne vrste, torej tiste brez logaritemske transformacije, samo kot zanimanje, kaj točno se dogaja.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram osnovne časovne vrste.", results='hide'}
acf2(ts_prosta, main = "", max.lag = 63)
```

Kot pri avtokorelogramu in parcialnem avtokorelogramu je zelo podobna situacija kot pri logaritmirani časovni vrsti.

### Diferenciranje 

Kot sva že napisala zgoraj, koeficienti avtokorelacije nakazujejo na trend v logaritmirani časovni vrsti, zato jo enkrat diferenciramo in poskušamo dobiti stacionarno časovno vrsto.

```{r, fig.cap="Logaritmirana osnovna in logaritmirana diferencirana časovna vrsta.", fig.dim=c(10,3.7)}
par(mfrow=c(1,2))
plot(ts_prosta_log, main="logaritmirana", xlab="leto", ylab="stevilo delovnih mest", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
plot(diff(ts_prosta_log, lag=1), main="diferenciranje 1. stopnje", xlab="leto", ylab="", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
```

Lahko bi rekli, da smo z diferenciranjem linearnega trenda dobili stacionarno časovno vrsto. Bolje temu zadoščamo sicer na levi strani drugega grafa, saj izgleda da je pričakovana vrednost enaka 0 in variabilnost dokaj končna, na desni strani, pri letu 2020 pa je še veden vpliv Covid-19 epidemije.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram logaritmirane diferencirane časovne vrste.", results='hide'}
acf2(diff(ts_prosta_log, lag=1), main = "", max.lag = 24)
```

Na zgornjem avtokorelogramu in parcialnem avtokorelogramu vidimo, da z diferenciranjem poskrbimo, da niso več prisotni statistično značilni koeficienti avtokorelacije, kar pomeni, da v modelu ni statistično značilne korelacije med členi časovne vrste. Zanimivo je le videti, da imamo nekoliko večji koeficient od ostalih pri odlogu "1.5" in pri odlogu "3" - morda je to nekaj kar še vedno malo bolj vpliva na avtokorelacijo, ampak je statistično neznačilno.

### Izbira ustreznega modela

V model sva najprej vključila diferenciranje prvega reda. Gre za ARIMA model s koeficienti $p$ = 0, $d$ = 1 in $q$ = 0 

```{r fig.cap="Ostanki modela, avtokorelogram in p-vrednosti Ljung-Box testa.", fig.height=5, fig.width=6, results='hide'}
# model za diferenciranje
mod.dif <- arima(ts_prosta_log, order = c(0, 1, 0))

# diagnostika ostankov modela
#par(mfrow=c(1,3))
#plot(ts(mod.dif$resid), xlab='čas', ylab = "ostanki modela")
#acf(mod.dif$resid, main = "")
#pacf(mod.dif$resid, main = "")
sarima(ts_prosta_log, p = 0, d = 1, q = 0, details = TRUE)
```

Koeficienti avtokorelacije so znotraj 95% intervala zaupanja, torej so statistično neznačilni, kar pomeni, da v modelu ni statistično značilne korelacije med ostanki(preverili smo tudi z Ljung-Box testom, kjer nismo mogli zavrnili ničelne domneve, da v tej časovni vrsti ostankov ni več avtokorelacije). Na podlagi tega lahko predpostavljamo, da ostanki so beli šum.

```{r, results='hide'}
Box.test(mod.dif$resid, lag = 10, type = c("Ljung-Box"))
```

### Napoved

Sedaj bova poskušala z modelom še napovedati število prostih delovnih mest za nekaj let vnaprej. Ker naju zanima kako dober je najin model, na začetku podatke razdeliva na testne in učne. Najbolj naju zanima kako bo napovedoval po letu 2020, če tega leta nima v učnih podatkih in kako napoveduje, če ga vključiva v učne podatke in napovedujeva od leta 2021 naprej.

```{r results=F, fig.cap="Časovna vrsta in napovedi na podlagi modela od leta 2020 naprej.", fig.width=6, fig.height=4}
prosta.delovna.mesta <- window(ts_prosta_log, start = c(2008, 1), end = c(2019, 4))
prosta.test <- window(ts_prosta_log, start = c(2020, 1), end = c(2023, 4))

sarima.for(prosta.delovna.mesta, n.ahead = 4*3, p = 0, d = 1, q = 0, plot.all = TRUE)
points(prosta.test, type = "o")
```

Jasno je, da napoved ni najboljša, saj ostanki vrste predstavljajo beli šum in pričakovano že na začetku poglavja, da model ne zna napovedati padca v letu 2020, saj je naučen po naraščajočem trendu, kar napovedi tudi prikazujejo. Ker so slabe napovedi, so temu primerni tudi izjemno široki 95% intervali zaupanja.

Poglejmo si sedaj še, kakšne so napovedi, če v učno množico vključimo podatke iz leta 2020.

```{r results=F, fig.cap="Časovna vrsta in napovedi na podlagi modela od leta 2021 naprej.", fig.width=6, fig.height=4}
prosta.delovna.mesta <- window(ts_prosta_log, start = c(2008, 1), end = c(2020, 4))
prosta.test <- window(ts_prosta_log, start = c(2021, 1), end = c(2023, 4))

sarima.for(prosta.delovna.mesta, n.ahead = 4*2, p = 0, d = 1, q = 0, plot.all = TRUE)
points(prosta.test, type = "o")
```

Pričakovano tudi sedaj napovedi niso ravno informativne, model je prevzel trend zadnjega leta in ga je nadaljeval tudi naprej.

Sedaj pa napovejmo samo za zadnje leto, leto 2023, da bo časovna vrsta imela v učnih podatkih in padec leta 2020 ter potem ponovno rast.

```{r results=F, fig.cap="Časovna vrsta in napovedi na podlagi modela od leta 2023 naprej.", fig.width=6, fig.height=4}
prosta.delovna.mesta <- window(ts_prosta_log, start = c(2008, 1), end = c(2022, 4))
prosta.test <- window(ts_prosta_log, start = c(2023, 1), end = c(2023, 4))

sarima.for(prosta.delovna.mesta, n.ahead = 4, p = 0, d = 1, q = 0, plot.all = TRUE)
points(prosta.test, type = "o")
```

Napovedi tudi tukaj niso pravilne in ne ravno najbolj informativne, najbolje zadane samo za en trenutek naprej, 95% intervali zaupanja pa so še vedno izjemno široki.

Ker je časovna vrsta tako zelo razgibana in ima veliko variabilnost ravno v zadnjih letih, težko uporabljamo ARIMA oz. SARIMA modele za napovedovanje prihodnjih vrednosti.

\newpage

## Časovna vrsta _Gostinstvo zasedena delovna mesta 1+_

### Pregled časovne vrste

Podatke imamo za leta od 2008 do leta 2023 za vsako kvartalno obdobje.

Na spodnjem grafu porazdelitve zasedenih delovnih mest v gostinstvu glede na leta lahko vidimo, da bo proti koncu variabilnost časovne vrste zelo nekonstantna v primerjavi z ostalimi leti, predvsem v letu 2020 in 2021. Pri časovni vrsti na začetku pričakujemo padajoč trend do leta 2014, ki nato postane pozitiven ter potem velike spremembe v letu 2020. Glede na kvartal je srednja vrednost dokaj enaka, malenkost odstopa morda le tretje kvartalno obdobje. Nekaj razlik je tudi v variabilnosti vrednosti znotraj kvartalnega obdobja.

```{r fig.height=3, fig.width=6, message=FALSE, warning=FALSE, fig.cap="Porazdelitev zasedenih delovnih v gostinstvu, kjer je zaposlena vsaj 1 oseba, glede na leto."}
df = data.frame(time = data1$...1, zasedena = data1$`Zasedena_1+_I GOSTINSTVO`)
df <- separate(df, time, into = c("year", "Q"), sep = "Q")

ggplot(df, aes(x= year, y= zasedena, fill=year)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("leto") + ylab("stevilo prostih delovnih mest")
```

```{r fig.height=3, fig.width=6, message=FALSE, warning=FALSE, fig.cap="Porazdelitev zasedenih delovnih v gostinstvu, kjer je zaposlena vsaj 1 oseba, glede na kvartal."}
ggplot(df, aes(x= Q, y= zasedena, fill=Q)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("kvartal v letu") + ylab("stevilo prostih delovnih mest")
```

Narišimo si sedaj časovno vrsto, ki jo bomo v nadaljevanju podrobneje analizirali.

```{r echo=FALSE, fig.cap="Časovna vrsta 'Gostinstvo zasedena delovna mesta 1+'.", fig.dim=c(6,3.7)}
plot.ts(ts_zasedena, type = "o", pch = 16, cex=0.6, xlab = "leto", ylab = "stevilo delovnih mest",  xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))

# gladilnik
gladilnik <- lowess(time(ts_zasedena),ts_zasedena)
points(gladilnik$x, gladilnik$y, type="l", col = "blue")
```

Kot sva omenila že zgoraj je iz grafa časovne vrste možno opaziti priostnost trenda. Ta je od leta 2008 do 2014 padajoč, nato pa se obrne in začne strmo naraščati. Sezonskosti ni mogoče zaznati, saj so lokalni ekstremi bolj naključni, kot da bi se ponavljali v ciklu. 

Vidno pa je ekstremno obdobje (čas pandemije Covid-19) in to ravno proti koncu časovne vrste. To obdobje bo verjetno povzorčalo težave pri iskanju ustreznega modela za napovedovanje prihodnjih zasedenih delovnih mest v gostinstvu, kjer je zaposlena 1 oseba. Če bi podate razdelili na učno in testno množico in v testno množico vzamemo zadnja 3 leta v naših podatkih, napovedi modela zagotovo ne bodo pravilne, saj se bo model učil na razmeroma normalnih in predvidljivih podatkih. 

### Transformacija časovne vrste

S pomočjo BoxCox testa, ugotovimo, da je 95% interval dokaj širok in vsebuje tako $\lambda=0$ in $\lambda=1$. Uporabili bomo logaritemsko transformacijo in časovno vrsto primerjali s časovno vrsto, kjer transformacije ne uporabimo.

```{r results='hide'}
time = 1 + frequency(ts_zasedena) * (time(ts_zasedena) - start(ts_zasedena)[1])

model_zasedena1 = lm(ts_zasedena~ time)
model_zasedena2 = lm(ts_zasedena~ time + I(time^2))
model_zasedena3 = lm(ts_zasedena~ time + I(time^2) + I(time^3))
model_zasedena4 = lm(ts_zasedena~ ns(time, df = 6))

anova(model_zasedena1, model_zasedena2, model_zasedena3, model_zasedena4)

# Box-Cox za 'Gostinstvo zasedena delovna mesta 1+'.
rez = boxCox(model_zasedena4, plotit = F)
lambda = rez$x[which.max(rez$y)]
# vsebuje tako Lambda = 0 in Lambda = 1
ts_zasedena_log = log(ts_zasedena)

# plot(time, ts_zasedena, type = "o", cex=0.5)
# points(time, model_zasedena4$fitted.values, type="l", col = "red")
```

```{r echo=FALSE, fig.cap="Osnovna in logaritmirana časovna vrsta 'Gostinstvo zasedena delovna mesta 1+'.", fig.dim=c(10,3.7)}
par(mfrow=c(1,2))
plot.ts(ts_zasedena, type = "o", pch = 16, cex=0.6, xlab = "leto", ylab = "stevilo delovnih mest",  xaxt="n", main="osnovna")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
# gladilnik
gladilnik <- lowess(time(ts_zasedena),ts_zasedena)
points(gladilnik$x, gladilnik$y, type="l", col = "blue")

plot.ts(ts_zasedena_log, type = "o", pch = 16, cex=0.6, xlab = "leto", ylab = "",  xaxt="n", main="transformirana")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
# gladilnik
gladilnik <- lowess(time(ts_zasedena_log),ts_zasedena_log)
points(gladilnik$x, gladilnik$y, type="l", col = "blue")
```

Krivulji osnovne in transponirane časovne vrste sta si identični, z izjemo razpona vrednosti na $y$-osi. Zato nadaljujmo analizo z netransformirano časovno vrsto.


### Analiza avtokoreliranosti 

Na prvem grafu je vidno, da koeficienti avtokorelacije počasi padajo, torej časovna vrsta vsebuje trend, ki ga bi bilo treba modelirati. Sprva je bil narisan osnovni avtokorelogram, s katerega se je videlo, da če bi povečali odloge(_Lag_), bi morda bilo videti nihanje. Na spodnjem avtokorelogramu imamo povečane odloge in koeficienti avtokorelacije morda nakazujejo na zelo počasno nihanje.

Parcialni avtokorelogram ne prikazuje posebnosti, imamo samo en koeficient parcialne avtokorelacije statistično značilen (kasneje sta se dva vendar jih zaradi oddaljenosti ne upoštevamo), zato sklepava, da bomo v modelu imeli red avtoregresijskega modela enak 1 ali pa celo 0.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram logaritmirane časovne vrste.", results='hide'}
acf2(ts_zasedena, main = "", max.lag = 63)
```

### Diferenciranje 

Kot sva že napisala zgoraj, koeficienti avtokorelacije nakazujejo na trend v časovni vrsti, zato jo enkrat diferenciramo in poskušamo dobiti stacionarno časovno vrsto.

```{r, fig.cap="Oosnovna in diferencirana časovna vrsta.", fig.dim=c(10,3.7)}
par(mfrow=c(1,2))
plot(ts_zasedena, main="osnovna", xlab="leto", ylab="stevilo delovnih mest", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
plot(diff(ts_zasedena, lag=1), main="diferenciranje 1. stopnje", xlab="leto", ylab="", xaxt="n")
axis(1, at=c(2008, 2011, 2014, 2017, 2020, 2023), labels=c("2008", "2011", "2014", "2017", "2020", "2023"))
```

Lahko bi rekli, da smo z diferenciranjem linearnega trenda dobili stacionarno časovno vrsto. Bolje temu zadoščamo sicer na levi strani drugega grafa, saj izgleda da je pričakovana vrednost enaka 0 in variabilnost dokaj končna, na desni strani, pri letu 2020 pa je še vedeno vpliv Covid-19 epidemije.

```{r, fig.cap="Avtokorelogram in parcialni avtokorelogram logaritmirane diferencirane časovne vrste.", results='hide'}
acf2(diff(ts_zasedena, lag=1), main = "", max.lag = 24)
```

Na zgornjem avtokorelogramu in parcialnem avtokorelogramu vidimo, da z diferenciranjem poskrbimo, da niso več prisotni statistično značilni koeficienti avtokorelacije, kar pomeni, da v modelu ni statistično značilne korelacije med členi časovne vrste. 

### Izbira ustreznega modela

V model sva najprej vključila diferenciranje prvega reda. Gre za ARIMA model s koeficienti $p$ = 0, $d$ = 1 in $q$ = 0 

```{r fig.cap="Ostanki modela, avtokorelogram in p-vrednosti Ljung-Box testa.", fig.height=5, fig.width=6, results='hide'}
# model za diferenciranje
mod.dif <- arima(ts_zasedena, order = c(0, 1, 0))

# diagnostika ostankov modela
# par(mfrow=c(1,3))
# plot(ts(mod.dif$resid), xlab='čas', ylab = "ostanki modela")
# acf(mod.dif$resid, main = "")
# pacf(mod.dif$resid, main = "")
sarima(ts_zasedena, p = 0, d = 1, q = 0, details = TRUE)
```

Koeficienti avtokorelacije so znotraj 95% intervala zaupanja, torej so statistično neznačilni, kar pomeni, da v modelu ni statistično značilne korelacije med ostanki(preverili smo tudi z Ljung-Box testom, kjer nismo mogli zavrnili ničelne domneve, da v tej časovni vrsti ostankov ni več avtokorelacije). Na podlagi tega lahko predpostavljamo, da ostanki so beli šum.

```{r, results='hide'}
Box.test(mod.dif$resid, lag = 10, type = c("Ljung-Box"))
```

### Napoved

Sedaj bova poskušala z modelom še napovedati število zasedenih delovnih mest za nekaj let vnaprej. Ker naju zanima kako dober je najin model, na začetku podatke razdeliva na testne in učne. Najbolj naju zanima kako bo napovedoval po letu 2020, če tega leta nima v učnih podatkih in kako napoveduje, če ga vključiva v učne podatke in napovedujeva od leta 2021 naprej.

```{r results=F, fig.cap="Časovna vrsta in napovedi na podlagi modela od leta 2020 naprej.", fig.width=6, fig.height=4}
zasedena.delovna.mesta <- window(ts_zasedena, start = c(2008, 1), end = c(2019, 4))
zasedena.test <- window(ts_zasedena, start = c(2020, 1), end = c(2023, 4))

sarima.for(zasedena.delovna.mesta, n.ahead = 4*3, p = 0, d = 1, q = 0, plot.all = TRUE)
points(zasedena.test, type = "o")
```

Jasno je, da napoved ni najboljša, saj ostanki vrste predstavljajo beli šum in pričakovano že na začetku poglavja, da model ne zna napovedati padca v letu 2020, saj je naučen po naraščajočem trendu, kar napovedi tudi prikazujejo. Ker so slabe napovedi, so temu primerni tudi izjemno široki 95% intervali zaupanja.

Poglejmo si sedaj še, kakšne so napovedi, če v učno množico vključimo podatke iz leta 2020.

```{r results=F, fig.cap="Časovna vrsta in napovedi na podlagi modela od leta 2021 naprej.", fig.width=6, fig.height=4}
zasedena.delovna.mesta <- window(ts_zasedena, start = c(2008, 1), end = c(2020, 4))
zasedena.test <- window(ts_zasedena, start = c(2021, 1), end = c(2023, 4))

sarima.for(zasedena.delovna.mesta, n.ahead = 4*2, p = 0, d = 1, q = 0, plot.all = TRUE)
points(zasedena.test, type = "o")
```

Pričakovano tudi sedaj napovedi niso ravno informativne, model je prevzel trend zadnjega leta in ga je nadaljeval tudi naprej.

Sedaj pa napovejmo samo za zadnje leto, leto 2023, da bo časovna vrsta imela v učnih podatkih in padec leta 2020 ter potem ponovno rast.

```{r results=F, fig.cap="Časovna vrsta in napovedi na podlagi modela od leta 2023 naprej.", fig.width=6, fig.height=4}
zasedena.delovna.mesta <- window(ts_zasedena, start = c(2008, 1), end = c(2022, 4))
zasedena.test <- window(ts_zasedena, start = c(2023, 1), end = c(2023, 4))

sarima.for(zasedena.delovna.mesta, n.ahead = 4, p = 0, d = 1, q = 0, plot.all = TRUE)
points(zasedena.test, type = "o")
```

Napovedi tudi tukaj niso pravilne in ne ravno najbolj informativne, najbolje zadane samo za en trenutek naprej, 95% intervali zaupanja pa so še vedno izjemno široki.

Ker je časovna vrsta tako zelo razgibana in ima veliko variabilnost ravno v zadnjih letih, težko uporabljamo ARIMA oz. SARIMA modele za napovedovanje prihodnjih vrednosti.

\newpage

<!--
###############################################################################
PROSTORSKI PROCES
###############################################################################
-->

\newpage

# Analiza prostorskega procesa

```{r}
data = read.table("podatki.txt", header=T)

podatki = data[,c("vrsta", "lokacija", "NDRE_jul", 
                  "swc", "gostota", "pF2", "pF4.2", "aw", "X", "Y")]

# uporabiva pri "Analiza prostorske korelacije"
pod = podatki

prostorski = as.geodata(podatki, coords.col = 9:10, data.col = 3,
                        covar.col = 4:8,
                        covar.names = c("swc", "gostota", "pF2", "pF4.2", "aw"))
```

## Predstavitev podatkov

Podatki so bili pridobljeni kot meritev več različnih spremenljivk na izbrani njivi v
Šempasu. Podatki tal so pridobljeni 18. 7. 2023 iz globine tal 20 cm, izmerjeni parametri pa so bili:

* _swc_ je gravimetrična vsebnost vode v tleh (vol. %)
* _gostota_ je gostota tal (g/cm3)
* _pF2_ je vsebnost vode pri matričnem potencialu vode pF 2.0
* _pF4.2_ je vsebnost vode pri matričnem potencialu vode pF 4.2
* _aw_ je rastlinam razpoložljiva voda v tleh (available water) (pF 2.0 - pF 4.2)

Podrobneje bova obravnala vegetacijski indeks *NDRE* v mesecu juliju in zgoraj napisani izmerjeni parametri lahko, poleg lokacije, tudi vplivajo na vegetacijski indeks.

Na spodnji sliki si lahko ogledamo še načrt meritev.

![](Šempas merilna shema.pdf){width=60%}

### Vegetacijski indeks NDRE {-}

Vegetacijski indeks NDRE (Normalized Difference Red Edge) je spektralni indeks, ki se uporablja v daljinskem zaznavanju za merjenje vsebnosti klorofila v rastlinah. Pogosto se uporablja v preciznem kmetijstvu za optimizacijo pridelkov, spremljanje zdravja rastlin, določanje potreb po gnojilih in drugih kmetijskih praks. Uporaba tega indeksa omogoča bolj ciljno usmerjene in učinkovite kmetijske posege, kar lahko vodi k večji produktivnosti in trajnosti.

<!--https://eos.com/make-an-analysis/ndre/-->


### Grafični prikaz parametrov

Najprej si poglejmo s kakšnimi podatki imamo opravka v našem podatkovnem okvirju.

```{r fig.height=3.5, fig.width=10, message=FALSE, warning=FALSE, fig.cap="Porazdelitev parametrov glede na vrsto.", results=T}
df = data 
df$vrsta <- factor(df$vrsta)
df$lokacija <- factor(df$lokacija)

g1=ggplot(df, aes(x= vrsta, y= swc, fill=vrsta)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("vrsta") + ylab("gravimetrična vsebnost vode v tleh (vol. %)")

g2=ggplot(df, aes(x= vrsta, y= gostota, fill=vrsta)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("vrsta") + ylab("gostota tal (g/cm3)")

g3=ggplot(df, aes(x= vrsta, y= pF2, fill=vrsta)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("vrsta") + ylab("vsebnost vode pri pF 2.0")

g4=ggplot(df, aes(x= vrsta, y= pF4.2, fill=vrsta)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("vrsta") + ylab("vsebnost vode pri pF 4.2")

g5=ggplot(df, aes(x= vrsta, y= aw, fill=vrsta)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("vrsta") + ylab("available water(pF 2.0 - pF 4.2)")

grid.arrange(g1, g2, g3, g4, g5, nrow = 2, ncol = 3)
```

```{r fig.height=3.5, fig.width=10, message=FALSE, warning=FALSE, fig.cap="Porazdelitev parametrov glede na lokacijo.", results=T}
g1=ggplot(df, aes(x= lokacija, y= swc, fill=lokacija)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("lokacija") + ylab("gravimetrična vsebnost vode v tleh (vol. %)")

g2=ggplot(df, aes(x= lokacija, y= gostota, fill=lokacija)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("lokacija") + ylab("gostota tal (g/cm3)")

g3=ggplot(df, aes(x= lokacija, y= pF2, fill=lokacija)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("lokacija") + ylab("vsebnost vode pri pF 2.0")

g4=ggplot(df, aes(x= lokacija, y= pF4.2, fill=lokacija)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("lokacija") + ylab("vsebnost vode pri pF 4.2")

g5=ggplot(df, aes(x= lokacija, y= aw, fill=lokacija)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("lokacija") + ylab("available water(pF 2.0 - pF 4.2)")

grid.arrange(g1, g2, g3, g4, g5, nrow = 2, ncol = 3)
```

Glede na vrsto in lokacijo vidimo, da imajo parametri različne variabilnosti, prav tako je razpon vrednosti, še posebaj glede na lokacijo, zelo različen. 

```{r fig.height=3.5, fig.width=10, message=FALSE, warning=FALSE, fig.cap="Porazdelitev spremenljivke NDRE za mesec julij glede na lokacijo in vrsto.", results=T}
g1=ggplot(df, aes(x= lokacija, y= NDRE_jul, fill=lokacija)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("lokacija") + ylab("NDRE")

g2=ggplot(df, aes(x= vrsta, y= NDRE_jul, fill=vrsta)) +
  geom_boxplot() +
  #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_light() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)) +
  xlab("vrsta") + ylab("NDRE")
grid.arrange(g1, g2, nrow = 1, ncol = 2)
```

Tudi porazdelitve indeksa NDRE se glede na vrsto in lokacijo razlikujejo, njihova variabilnost je različna ter pri določenih vrstah in lokacijah opazimo osamelce ter asimetričnost.

## Grafični prikaz

Na spodnjem grafu lahko vidimo lokacije meritev, na katerem sta ploščina in barva krogcev sorazmerna z vrednostjo spremenljivke _NDRE_jul_, podatki so razdeljeni v štiri razrede, ki so določeni s kvantili.

```{r fig.cap="Grafični prikaz lokacij in relativne vrednosti spremenljivke 'NDRE'."}
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(-55, 245, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2, 
       col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
```

Poglejmo si še nekoliko podrobnejši prikaz, kjer nas bosta zanimala predvsem razsevna grafikona *vrsta* in *NDRE_jul*, ter *lokacija* in *NDRE_jul*. 

```{r fig.cap="Predstavitev realizacije prostorskega procesa 'NDRE'.", fig.height=5, fig.width=8}
plot(prostorski)
```

Iz razsevnih grafikonov ni videti odvisnosti spremenljivke *NDRE_jul* od koordinat lokacije. Iz prvega grafa in pa zgornjega levega grafa lahko opazimo nek vzorec, kar nam nakazuje na prisotnost prostorske korelacije.

Torej iz zgornjega desnega grafa (vrednosti v odvisnoti od _lokacija_) in spodnjega levega grafa (vrednosti v odvisnoti od _vrsta_) ni možno razbrati priostnosti trenda in nekonstantne varinace, zato ne bova naredila podrobnejše analize morebitne nestacionarnosti.

<!-- Tom: jst bi reku da tukej nimava kej velik za narest ker se vsaj men zdi da 
grafi ne kazejo nekega trenda niti nekonstantne variance...
Neza: tole sm dodala kr zgorej ker brezveze, da mava šeenkrat isti graf...
Tom: ok super
-->

## Analiza prostorske korelacije

### Razsevni grafikon

Ker naju natančneje zanima izražanje prostorske korelacije, si nariševa razsevne grafikone, na katerih so prikazani pari podatkov na različnih prostorskih odlogih. Črta nam prikazuje idealno povezanost z vrednostjo korelacijskega koeficienta 1.

```{r fig.cap="Prostorska korelacija za 'NDRE(jul)'.", fig.height=5, fig.width=7}
# razsevni grafikon
coordinates(pod) = c("X", "Y")
hscat(NDRE_jul ~ 1, pod, 0:50)
```

Za pare podatkov o **NDRE_jul** glede na razrede oddaljenosti lahko vidimo, da se z oddaljenostjo prostorska korelacija zmanjšuje (Pearsonov koeficient korelacije). Lahko bi torej reki, da na zelo kratkih razdaljah imamo majhno povezanost, ki na daljših razdaljah še pada.

### Oblak semivariagrama in vzorčni semivariogram

Poglejmo analizo prostorske korelacije še s pomočjo oblaka semivariograma in vzorčnega semivariograma.

```{r fig.cap="Oblak semivariograma za 'NDRE(jul)'(levo), okvirji z ročaji za vrednosti klasičnega variaograma po razdaljah med lokacijami(sredina) in za vrednosti robustnega vzorčnega variograma(desno)." , fig.height=3.5, fig.width=10, results=F}
par(mfrow=c(1,3))
variog1.cloud <- variog(prostorski, option = "cloud", max.dist = 180)
plot(variog1.cloud)
# klasicni vzorcni variogram
variog1.cloud.bin <- variog(prostorski, bin.cloud = TRUE, max.dist = 180)
plot(variog1.cloud.bin, bin.cloud = TRUE)
# robustni vzorcni variogram
variog1.cloud.bin.c <- variog(prostorski, bin.cloud = TRUE,
                              estimator.type = "modulus", max.dist = 180) 
plot(variog1.cloud.bin.c, bin.cloud = TRUE)
```

Na skrajno levem zgornjem grafu vidimo, da vrednosti _NDRE_jul_ predstavljajo meritve v pravilni mreži točk, saj oblak variograma prikazuje diskretne vrednosti razdalj med lokcijami in so točke narisane v črtah. Porazdelitve vrednosti vzorčnega variograma pa so asimetrične v vsakem razredu(razredi predstavljajo razdalje), prav tako pa imamo nekaj osamelcev. Na zadnjem, robustnem vzorčnem variogramu, kjer na nek način "posekamo" vpliv vrednosti, ki zelo odstopajo, vidimo, da so porazdelitve glede na razrede  sedaj bistveno drugačne in nekateri osamelci izginejo.

Na spodnjem levem vzorčnem semivariogram s povprečji za posamezne razrede razdalje lahko iz razporeditve točk razberemo, da so pri manjših razdaljah vzorčne variogramske vrednosti manjše, z naraščajočo razdaljo se povečujejo in se z nadaljnjim večanjem razdalje ne ustalijo ravno oz. ne izgleda, kot da bi se približevale določenemu pragu, torej kaže na prisotnost prostorskega trenda v podatkih.

Vzorčni variogram za ostanke prostorskega trenda(desno) pokaže, da je prostorska korelacija med ostanki precej šibkejša.

```{r results=F, fig.cap="Vzorčni semivariogram za 'NDRE(jul)'."}
variog1 = variog(prostorski, max.dist = 180)
plot(variog1, pch = 16, type ="o")
```

Do sedaj sva proučevala prostorsko korelacjo ne glede na smer v prostoru, torej sva predpostavila izotropni prostorski proces. Zato narišimo še usmerjene semivariograme za določene smeri v prostoru in s tem preverimo ali je predpostavka izotropnosti upravičena.

```{r results=F, fig.cap="Vzorčni variogrami za 'NDRE(jul)' za štiri glavne smeri."}
variog1.4 <- variog4(prostorski, uvec = seq(0, 180, by = 20))
plot(variog1.4, type = "b", main = "", pch = 16, lwd = 2, ylim=c(0,180))
```

Vzorčni variogrami za _NDRE_jul_ za štiri glavne smeri izraža izotropijo, saj že na krajših razdaljah vidimo razlike v vzorčnih variogramih za različne smeri, ki se potem sicer zelo hitro zmanjša(_pri razdalji 50_). Tudi začetne razlike so dokaj majhne. Torej bi glede na graf morda bilo potrebno modeliranje prostorske korelacije na kratke razdalje. 

<!-- Tom: jst bi glede na vrednosti na zacetku reku da ni izpolnena predpostavka izotropnosti...kaj pravis? 
Neza: torej korva modelirat prosorsko korelacijo? Sam 3 smeri so okej oziroma nekak da so premice vzporedne vsaj na zacetku, s tem k smer 45 stopin gre pa čist po svoje na začetku, misls da morva to kako opisat? Torej 45 stopinj to je potem severo-vzhod? 
Zdej sm sla gledat tiste padavine v sloveniji al kaj, tm tud niso na zacetku cist okej, pa nic neki ful ne komplicira

Tole zdej sploh nevem več, pomojem je tole pr nama čist okej in je komentar k je napisan narobe, ker tm pr zadnjem primeru za slovenijo je kr neki, pa ni nic napisan da ne bi blo okej...
-->

### Ovojnice za vzorčni semivariogram

Da bi dobila širšo sliko o prostorski povezanosti procesa, pri raziskovanju prostorske povezanosti uporabiva Monte Carlo simulacije na podlagi te realizacij prostorskega procesa. Če padejo vse vrednosti osnovnega vzorčnega variograma znotraj ovojnice, ki je določena z robnima variogramoma permutiranih vrednosti, potem podatki ne nakazujejo prostorske povezanosti. Predvsem naju zanima nekaj prvih točk, ki odražajo korelacijo na manjših razdaljah.

<!-- Tom: jst bootstrap ovojnic nism nasu nikjer smo pa delal Monte Carlo ovojnice tko da je vrjetno to mislna...-->

```{r results=F, fig.cap="Monte Carlo ovojnica semivariograma."}
# Monte Carlo ovojnica semivariograma
par(mfrow = c(1, 1))
bin <- variog(prostorski, uvec = c(0:180))
env.mc <- variog.mc.env(prostorski, obj.var = bin)
plot(bin, envelope = env.mc)
```

<!-- Tom: jst bi za vse tri reku da ni neke izrazite koreliranosti oz mogoce "Vzorčni variogram s povprečji za posamezne razrede razdalje" je se najbolj tak da bi lahko prikazoval neko korelacijo-->

Vidimo, da ni izrazite koreliranosti oz. podatki niso prostorsko korelirani.

## Model semivariograma za dane podatke

### Sferični model variograma brez zlatega zrna

Najprej sva parametre semivariograma ocenila z metodo Maximum Likelihood(ML), ki za začetne vrednosti vzame ocene dobljene s funkcijo `variofit`.

```{r results=F}
# sferični model variograma brez zlatega zrna
variogram1 <- variog(prostorski, max.dist = 180)

# na osnovi slike Vzorčni semivariogram za 'NDRE(jul)'
# prag variograma: nevem če ga imava, zadnja največja vrednost je 8e-04
# variogramski razmik: iz 4e-04 gre do 8e-04
# vpliv zlatega zrna: 

# interval seq(4e-04, 8e-04, l=20) za prag variograma
# interval seq(2, 8, by = 1) za variogramski razmik

initial.values <- expand.grid(seq(4e-04, 8e-04, l=20), seq(40, 140, by = 20))

# fit1 <- variofit(variogram1, cov.model = "sph", ini.cov.pars = c(8e-04, 4e-04),
#                  fix.nugget = TRUE, nugget = 0, max.dist = 10,
#                  weights = "npairs")

fit1 <- variofit(variogram1, cov.model = "sph", ini.cov.pars = initial.values,
                 fix.nugget = TRUE, nugget = 0, max.dist = 180,
                 weights = "npairs")

fit1.ml <- likfit(prostorski, ini.cov.pars = fit1, cov.model = "sph",
                  fix.nugget = TRUE, lik.met = "ML") 
fit1.ml
```

```{r, results=F, fig.cap="Profile-log-likelihood za parametra sferičnega modela semivariograma brez zlatega zrna kaže na napačno izbiro modela prostorske korelacije."}
par(mfrow = c(1, 2))
# plot(proflik(fit1.ml, geodata = prostorski, sill.val = seq(10, 70, l = 20),
#              range.val = seq(1, 10, l = 12), uni.only = TRUE)) 

# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1.ml, geodata = prostorski, sill.val = seq(0.00001, 0.003, l = 20),
             range.val = seq(0.1, 100, l = 20), uni.only = TRUE))
```

Izgleda kot da po metodi največjega verjetja z začetnimi vrednostmi praga in razmika variograma **fit1** dobimo optimalne rešitve za parametre semivariograma.
<!-- Neza25: hmm kle mava zdej v opisu grafa napisan eno spodi pod grafi pa drugo...-->

```{r, fig.cap="Modela vzorčnega semivariograma za prostorski trend, na podlagi vzorčnega variograma in na podlagi oblaka variograma z ML."}
plot(variog1, pch = 16)
lines(fit1, col = "red", lwd = 2)
lines(fit1.ml, col = "green", lwd = 2)
legend("bottomright", col = c("red", "green"), lty = 1, lwd = 2, legend = c("fit1", "fit1.ml"))
```

Vidimo, da z modelom _fit1.ml_, kjer smo kot metodo uporabili Maximum likelihood, nekoliko bolje opisali vrednosti semivarianc za manjše razdalje. V celoti pa bi lahko rekli da z modelom _fit1_ bolje opišemo vrednosti semivarianc za razdalje od 1 do 10.

V naslednjem koraku pri uporabi funkcije likfit dopustiva,da dobimo tudi oceno za zlato zrno.

```{r results=F}
# za oceno parametrov semivariograma z ML, ki za začetne vrednosti vzame 
# ocene dobljene s funkcijo variofit fit1, ki ocenjuje tudi zlato zrno
fit2.ml <- likfit(prostorski, ini.cov.pars = fit1, cov.model = "sph",
                  fix.nugget = FALSE, lik.met = "ML")  # fix.nugget = FALSE
fit2.ml
```

```{r, results=F, fig.cap="Profile-log-likelihood za parametre sferičnega modela semivariograma z zlatim zrnom."}
par(mfrow = c(1, 3))
# ni mi cist jasno kako dolocva sill.val, range.val, nugget.val
# sm zdej popravu tko da so lepsi grafi...ce jst prou razumem so to samo intervali
# na katerih narise grafe
plot(proflik(fit2.ml, geodata = prostorski, sill.val = seq(0.00001, 0.001, l = 20),
             range.val = seq(150, 200, l = 10), nugget.val = seq(0, 0.001, l = 20)),
             uni.only = TRUE)
```

Iz grafov lahko vidimo da po metodi največjega verjetja z začetnimi vrednostmi praga in razmika variograma **fit1** ne dobimo optimalne rešitve za $\phi$ (razmik-range). Optimalno rešitev dobimo le za $\sigma^2$ (prag semivariograma-sill) in $\tau$ (varianca zlatega zrna).

<!--
Iz grafov lahko vidimo da po metodi največjega verjetja z začetnimi vrednostmi praga in razmika variograma **fit1** ne dobimo optimalne rešitve za $\sigma^2$ (prag semivariograma-sill) in $\phi$ (razmik-range). Le za $\tau$ (varianca zlatega zrna) dobimo optimalno rešitev. To nakazuje na napačno izbiro modela prostorske korelacije.
-->
<!-- Okej wtf je to???
Tom: upam da ti je zdej malenkost bolj vsec-->

```{r, fig.cap="Modela vzorčnega semivariograma za prostorski trend, na podlagi vzorčnega variograma in na podlagi oblaka variograma z ML."}
plot(variog1, pch = 16)
lines(fit1.ml, col = "red", lwd = 2)
lines(fit2.ml, col = "green", lwd = 2)
legend("bottomright", col = c("red", "green"), lty = 1, lwd = 2,
legend = c("fit1.ml", "fit2.ml"))
```

Če med seboj primerjamo modela, pri katerem je vrednost zlatega zrna fiksna (rdeča) in model pri katerem ocenjujemo vrednost zlatega zrna (zelena). Izkaže se, da v primeru, ko ocenjujemo vrednost zlatega zrna bolje opišemo prvo in drugo vrednost semivariance, tretjo pa bolje opiše model s fiksnim zlatim zrnom, torej na zelo kratke razdalje je boljši model pri katerem ocenjujemo vrednost zlatega zrna (zelena, _fit2.ml_).

<!--Izkaže se, da v primeru fiksne vrednosti zlatega zrna bolje opišemo vrednosti semivarianc za manjše razdalje.-->

```{r results=F, fig.cap="Napovedi NDRE za mesec julij za dano območje - model semivarigrama fit1.ml(levo)."}
xy.napovedi = data.frame(x=data$X, y=data$Y)
nap1 <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
              cov.pars = c(fit1.ml$sigmasq, fit1.ml$phi),
              nugget = fit1.ml$nugget, locations = xy.napovedi)
nap2 <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
              cov.pars = c(fit2.ml$sigmasq, fit2.ml$phi),
              nugget = fit2.ml$nugget, locations = xy.napovedi)

levelplot(nap1$predict ~ nap1$locations[,1] + nap1$locations[,2], nap1, aspect = "fill",
          contour = FALSE, xlab = "X", ylab = "Y")
```

```{r results=F, fig.cap="Standardna napaka napovedi NDRE za mesec julij za dano območje - model semivarigrama fit1.ml."}
levelplot(sqrt(nap1$krige.var) ~ nap1$locations[,1] + nap1$locations[,2], nap1, aspect = "fill",
          contour = FALSE, xlab = "X", ylab = "Y")
```

```{r results=F, fig.cap="Napovedi NDRE za mesec julij za dano območje - model semivarigrama fit2.ml."}
par(mfrow=c(1,1))
levelplot(nap2$predict ~ nap2$locations[,1] + nap2$locations[,2], nap2, aspect = "fill",
          contour = FALSE, xlab = "X", ylab = "Y")
```

```{r results=F, fig.cap="Standardna napaka napovedi NDRE za mesec julij za dano območje - model semivarigrama fit2.ml."}
levelplot(sqrt(nap2$krige.var) ~ nap2$locations[,1] + nap2$locations[,2], nap2, aspect = "fill",
          contour = FALSE, xlab = "X", ylab = "Y")
```

### Gaussov model variograma brez zlatega zrna

Poskusila bova modelirati še z uporabo Gaussove kovariančne funkcije. Preverila bova ali z uporabo metode ML dobimo boljše prileganje vrednostim variograma. 

```{r results=F}
# Gaussov model variograma brez zlatega zrna
variogram2 <- variog(prostorski, max.dist = 180)

# na osnovi slike Vzorčni semivariogram za 'NDRE(jul)'
# prag variograma: nevem če ga imava, zadnja največja vrednost je 8e-04
# variogramski razmik: iz 4e-04 gre do 8e-04
# vpliv zlatega zrna: 

# interval seq(4e-04, 1e-03, l=20) za prag variograma
# interval seq(2, 8, by = 1) za variogramski razmik

initial.values <- expand.grid(seq(4e-04, 8e-04, l=20), seq(40, 140, by = 20))

# fit1 <- variofit(variogram1, cov.model = "sph", ini.cov.pars = c(8e-04, 4e-04),
#                  fix.nugget = TRUE, nugget = 0, max.dist = 10,
#                  weights = "npairs")

fit1_g <- variofit(variogram1, cov.model = "gaussian",
                   ini.cov.pars = initial.values,
                 fix.nugget = TRUE, nugget = 0, max.dist = 180,
                 weights = "npairs")

fit1_g.ml <- likfit(prostorski, ini.cov.pars = fit1, cov.model = "gaussian",
                  fix.nugget = TRUE, lik.met = "ML") 
fit1_g.ml
```

```{r, results=F, fig.cap="Profile-log-likelihood za parametra Gaussovega modela semivariograma brez zlatega zrna."}
par(mfrow = c(1, 2))
plot(proflik(fit1_g.ml, geodata = prostorski, 
             sill.val = seq(0.0001, 0.0015, l = 20),
             range.val = seq(15, 30, l = 5), uni.only = TRUE))
```

Izgleda kot da po metodi največjega verjetja z začetnimi vrednostmi praga in razmika variograma **fit1_g** dobimo optimalne rešitve za parametre semivariograma.

```{r, fig.cap="Modela vzorčnega semivariograma za prostorski trend, na podlagi vzorčnega variograma in na podlagi oblaka variograma z ML."}
plot(variogram2, pch = 16)
lines(fit1_g, col = "red", lwd = 2)
lines(fit1_g.ml, col = "green", lwd = 2)
legend("bottomright", col = c("red", "green"), lty = 1, lwd = 2,
legend = c("fit1", "fit1.ml"))
```

Ponovno vidimo, da z uporabo metode Maximum likelihood, torej modelom _fit1.ml_, bolje opišemo le prvi dve vrednosti vzorčnega semivariograma. Z modelom _fit1_ pa bolje opišemo vrednosti tudi pri večjih razdaljah, ampak pri velikih razdaljah(npr. 130 naprej) pa noben od modelov prav dober.

V naslednjem koraku pri uporabi funkcije _likfit_ dopustiva,da dobimo tudi oceno za zlato zrno.

```{r results=F}
# za oceno parametrov semivariograma z ML, ki za začetne vrednosti vzame 
# ocene dobljene s funkcijo variofit fit1, ki ocenjuje tudi zlato zrno
fit2_g.ml <- likfit(prostorski, ini.cov.pars = fit1_g, cov.model = "gaussian",
                  fix.nugget = FALSE, lik.met = "ML")  # fix.nugget = FALSE
fit2_g.ml
```

Iz spodnjih grafov lahko vidimo da po metodi največjega verjetja z začetnimi vrednostmi praga in razmika variograma **fit1_g** ne dobimo optimalne rešitve za $\phi$ (razmik-range). Optimalno rešitev dobimo le za $\sigma^2$ (prag semivariograma-sill) in $\tau$ (varianca zlatega zrna).

```{r, results=F,  fig.cap="Profile-log-likelihood za parametre Gaussovega modela semivariograma z zlatim zrnom."}
par(mfrow = c(1, 3))
# # ni mi cist jasno kako dolocva sill.val, range.val, nugget.val
# # sm zdej popravu tko da so lepsi grafi...ce jst prou razumem so to samo intervali
# # na katerih narise grafe
plot(proflik(fit2_g.ml, geodata = prostorski, sill.val = seq(0.00001, 0.002, l = 20),
             range.val = seq(15, 35, l = 20), nugget.val = seq(0, 0.001, l = 20)),
             uni.only = TRUE)
```

```{r, fig.cap="Modela vzorčnega semivariograma za prostorski trend, na podlagi vzorčnega variograma in na podlagi oblaka variograma z ML."}
plot(variog1, pch = 16)
lines(fit1_g.ml, col = "red", lwd = 2)
lines(fit2_g.ml, col = "green", lwd = 2)
legend("bottomright", col = c("red", "green"), lty = 1, lwd = 2,
legend = c("fit1_g.ml", "fit2_g.ml"))
```

Če med seboj primerjamo modela, pri katerem je vrednost zlatega zrna fiksna (rdeča, _fit1_g.ml_) in model pri katerem ocenjujemo vrednost zlatega zrna (zelena, _fit2_g.ml_). Izkaže se, da v primeru modela, kjer ocenjujemo vrednost zlatega zrna bolje opišemo vrednosti semivarianc za manjše razdalje, kasneje pa sta si modela skoraj enaka za ocenjevanje.

```{r results=F, fig.cap="Napovedi NDRE za mesec julij za dano območje - model semivarigrama fit1g.ml."}
nap <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "gaussian",
              cov.pars = c(fit1_g.ml$sigmasq, fit1_g.ml$phi),
              nugget = fit1_g.ml$nugget, locations = xy.napovedi)
levelplot(nap$predict ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
          contour = FALSE, xlab = "X", ylab = "Y")
```

```{r results=F, fig.cap="Standardna napaka napovedi NDRE za mesec julij za dano območje - model semivarigrama fit1g.ml."}
levelplot(sqrt(nap$krige.var) ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
          contour = FALSE, xlab = "X", ylab = "Y")
```

```{r results=F, fig.cap="Napovedi NDRE za mesec julij za dano območje - model semivarigrama fit2g.ml."}
nap <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "gaussian",
              cov.pars = c(fit2_g.ml$sigmasq, fit2_g.ml$phi),
              nugget = fit2_g.ml$nugget, locations = xy.napovedi)

levelplot(nap$predict ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
          contour = FALSE, xlab = "X", ylab = "Y")
```

```{r results=F, fig.cap="Standardna napaka napovedi NDRE za mesec julij za dano območje - model semivarigrama fit2g.ml."}
levelplot(sqrt(nap$krige.var) ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
          contour = FALSE, xlab = "X", ylab = "Y")
```
















