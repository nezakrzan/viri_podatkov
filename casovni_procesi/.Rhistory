col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(50, 210, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(50, 220, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(50, 230, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(50, 250, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(50, 240, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(50, 245, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(0, 245, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(-10, 245, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(-50, 245, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(-55, 245, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(110, 245, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(110, 1, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(110, 50, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(120, 45, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
points(prostorski, pt.div = "quartile", cex.min = 0.6, cex.max = 2, col = c(4, 3, 7, 2))
par(xpd = TRUE)
legend(-55, 245, c("0-25%", "25-50%","50-75%","75-100%"), ncol = 2,
col = c(4, 3, 10, 2), pch = 16, box.lty = 0)
plot(prostorski)
# razsevni grafikon
coordinates(pod) = c("X", "Y")
hscat(NDRE_jul ~ 1, pod, 0:6)
str(pod)
data = read.table("podatki.txt", header=T)
podatki = data[,c("vrsta", "lokacija", "NDRE_jul",
"swc", "gostota", "pF2", "pF4.2", "aw", "X", "Y")]
# uporabiva pri "Analiza prostorske korelacije"
pod = podatki
str(pod)
prostorski = as.geodata(podatki, coords.col = 9:10, data.col = 3,
covar.col = 4:8,
covar.names = c("swc", "gostota", "pF2", "pF4.2", "aw"))
str(pod)
# razsevni grafikon
coordinates(pod) = c("X", "Y")
hscat(NDRE_jul ~ 1, pod, 0:6)
# razsevni grafikon
coordinates(prostorski) = c("X", "Y")
# razsevni grafikon
coordinates(pod) = c("X", "Y")
str(pod)
hscat(NDRE_jul ~ 1, pod, 0:6)
View(pod)
View(podatki)
# razsevni grafikon
coordinates(pod) = c("vrsta", "lokacija")
data = read.table("podatki.txt", header=T)
podatki = data[,c("vrsta", "lokacija", "NDRE_jul",
"swc", "gostota", "pF2", "pF4.2", "aw", "X", "Y")]
# uporabiva pri "Analiza prostorske korelacije"
pod = podatki
prostorski = as.geodata(podatki, coords.col = 9:10, data.col = 3,
covar.col = 4:8,
covar.names = c("swc", "gostota", "pF2", "pF4.2", "aw"))
# razsevni grafikon
coordinates(pod) = c("vrsta", "lokacija")
hscat(NDRE_jul ~ 1, pod, 0:6)
data = read.table("podatki.txt", header=T)
podatki = data[,c("vrsta", "lokacija", "NDRE_jul",
"swc", "gostota", "pF2", "pF4.2", "aw", "X", "Y")]
# uporabiva pri "Analiza prostorske korelacije"
pod = podatki
prostorski = as.geodata(podatki, coords.col = 9:10, data.col = 3,
covar.col = 4:8,
covar.names = c("swc", "gostota", "pF2", "pF4.2", "aw"))
# razsevni grafikon
coordinates(pod) = c("X", "Y")
hscat(NDRE_jul ~ 20, pod, 0:150)
hscat(NDRE_jul ~ 1, pod, 0:150)
hscat(NDRE_jul ~ 1, pod, 0:100)
# razsevni grafikon
coordinates(pod) = c("X", "Y")
# razsevni grafikon
coordinates(pod) = c("X", "Y")
hscat(NDRE_jul ~ 1, pod, 0:100)
hscat(NDRE_jul ~ 1, pod, 0:50)
par(mfrow=c(1,3))
variog1.cloud <- variog(prostorski, option = "cloud", max.dist = 10)
plot(variog1.cloud)
par(mfrow=c(1,3))
variog1.cloud <- variog(prostorski, option = "cloud", max.dist = 180)
plot(variog1.cloud)
# klasicni vzorcni variogram
variog1.cloud.bin <- variog(prostorski, bin.cloud = TRUE, max.dist = 180)
plot(variog1.cloud.bin, bin.cloud = TRUE)
# robustni vzorcni variogram
variog1.cloud.bin.c <- variog(prostorski, bin.cloud = TRUE,
estimator.type = "modulus", max.dist = 8)
# robustni vzorcni variogram
variog1.cloud.bin.c <- variog(prostorski, bin.cloud = TRUE,
estimator.type = "modulus", max.dist = 180)
plot(variog1.cloud.bin.c, bin.cloud = TRUE)
variog1 = variog(prostorski, max.dist = 180)
plot(variog1, pch = 16, type ="o")
# tole nevem če rabva
variog2 <- variog(prostorski, trend = ~coords[,1] * coords[,2], max.dist = 180)
plot(variog2, pch = 16, type ="o")
variog1.4 <- variog4(prostorski, uvec = seq(1, 10, by = 1))
plot(variog1.4, type = "b", main = "", pch = 16, lwd = 2)
plot(variog1.4, type = "b", main = "", pch = 16, lwd = 2, ylim=180)
plot(variog1.4, type = "b", main = "", pch = 16, lwd = 2, ylim=c(0,180))
variog1.4 <- variog4(prostorski, uvec = seq(1, 10, by = 1))
seq(0, 180, by = 20)
variog1.4 <- variog4(prostorski, uvec = seq(0, 180, by = 20))
plot(variog1.4, type = "b", main = "", pch = 16, lwd = 2, ylim=c(0,180))
# Monte Carlo ovojnica semivariograma
par(mfrow = c(1, 1))
bin <- variog(prostorski, uvec = c(0:180))
env.mc <- variog.mc.env(prostorski, obj.var = bin)
plot(bin, envelope = env.mc)
# Monte Carlo ovojnica semivariograma
par(mfrow = c(1, 1))
bin <- variog(prostorski, uvec = c(0:180))
env.mc <- variog.mc.env(prostorski, obj.var = bin)
plot(bin, envelope = env.mc)
# Monte Carlo ovojnica semivariograma
par(mfrow = c(1, 1))
bin <- variog(prostorski, uvec = c(0:180))
env.mc <- variog.mc.env(prostorski, obj.var = bin)
plot(bin, envelope = env.mc)
# sferični model variograma brez zlatega zrna
variogram1 <- variog(prostorski, max.dist = 180)
initial.values <- expand.grid(seq(4e-04, 1e-03, l=20), seq(2, 8, by = 1))
fit1 <- variofit(variogram1, cov.model = "sph", ini.cov.pars = initial.values,
fix.nugget = TRUE, nugget = 0, max.dist = 10,
weights = "npairs")
fit1.ml <- likfit(prostorski, ini.cov.pars = fit1, cov.model = "sph",
fix.nugget = TRUE, lik.met = "ML")
fit1.ml
par(mfrow = c(1, 2))
# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1.ml, geodata = prostorski, sill.val = seq(0.0001, 0.003, l = 20),
range.val = seq(0.1, 6, l = 12), uni.only = TRUE))
# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1.ml, geodata = prostorski, sill.val = seq(0.0001, 0.003, l = 20),
range.val = seq(0.1, 10, l = 12), uni.only = TRUE))
# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1.ml, geodata = prostorski, sill.val = seq(0.0001, 0.003, l = 20),
range.val = seq(0.1, 100, l = 12), uni.only = TRUE))
# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1.ml, geodata = prostorski, sill.val = seq(0.0001, 0.003, l = 20),
range.val = seq(0.1, 100, l = 20), uni.only = TRUE))
# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1.ml, geodata = prostorski, sill.val = seq(0.000001, 0.003, l = 20),
range.val = seq(0.1, 100, l = 20), uni.only = TRUE))
# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1.ml, geodata = prostorski, sill.val = seq(0.00001, 0.003, l = 20),
range.val = seq(0.1, 100, l = 20), uni.only = TRUE))
plot(variog1, pch = 16)
lines(fit1, col = "red", lwd = 2)
lines(fit1.ml, col = "green", lwd = 2)
legend("bottomright", col = c("red", "green"), lty = 1, lwd = 2,
legend = c("fit1", "fit1.ml"))
# sferični model variograma brez zlatega zrna
variogram1 <- variog(prostorski, max.dist = 180)
# na osnovi slike Vzorčni semivariogram za 'NDRE(jul)'
# prag variograma: nevem če ga imava, zadnja največja vrednost je 8e-04
# variogramski razmik: iz 4e-04 gre do 8e-04
# vpliv zlatega zrna:
# interval seq(4e-04, 1e-03, l=20) za prag variograma
# interval seq(2, 8, by = 1) za variogramski razmik
initial.values <- expand.grid(seq(4e-04, 1e-03, l=20), seq(2, 8, by = 1))
# fit1 <- variofit(variogram1, cov.model = "sph", ini.cov.pars = c(8e-04, 4e-04),
#                  fix.nugget = TRUE, nugget = 0, max.dist = 10,
#                  weights = "npairs")
fit1 <- variofit(variogram1, cov.model = "sph", ini.cov.pars = initial.values,
fix.nugget = TRUE, nugget = 0, max.dist = 180,
weights = "npairs")
fit1.ml <- likfit(prostorski, ini.cov.pars = fit1, cov.model = "sph",
fix.nugget = TRUE, lik.met = "ML")
fit1.ml
par(mfrow = c(1, 2))
# plot(proflik(fit1.ml, geodata = prostorski, sill.val = seq(10, 70, l = 20),
#              range.val = seq(1, 10, l = 12), uni.only = TRUE))
# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1.ml, geodata = prostorski, sill.val = seq(0.00001, 0.003, l = 20),
range.val = seq(0.1, 100, l = 20), uni.only = TRUE))
variog1 = variog(prostorski, max.dist = 180)
plot(variog1, pch = 16, type ="o")
initial.values <- expand.grid(seq(4e-04, 8e-04, l=20), seq(40, 140, by = 20))
fit1 <- variofit(variogram1, cov.model = "sph", ini.cov.pars = initial.values,
fix.nugget = TRUE, nugget = 0, max.dist = 180,
weights = "npairs")
fit1.ml <- likfit(prostorski, ini.cov.pars = fit1, cov.model = "sph",
fix.nugget = TRUE, lik.met = "ML")
fit1.ml
# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1.ml, geodata = prostorski, sill.val = seq(0.00001, 0.003, l = 20),
range.val = seq(0.1, 100, l = 20), uni.only = TRUE))
plot(variog1, pch = 16)
lines(fit1, col = "red", lwd = 2)
lines(fit1.ml, col = "green", lwd = 2)
legend("bottomright", col = c("red", "green"), lty = 1, lwd = 2, legend = c("fit1", "fit1.ml"))
# za oceno parametrov semivariograma z ML, ki za začetne vrednosti vzame
# ocene dobljene s funkcijo variofit fit1, ki ocenjuje tudi zlato zrno
fit2.ml <- likfit(prostorski, ini.cov.pars = fit1, cov.model = "sph",
fix.nugget = FALSE, lik.met = "ML")  # fix.nugget = FALSE
fit2.ml
par(mfrow = c(1, 3))
# ni mi cist jasno kako dolocva sill.val, range.val, nugget.val
# sm zdej popravu tko da so lepsi grafi...ce jst prou razumem so to samo intervali
# na katerih narise grafe
plot(proflik(fit2.ml, geodata = prostorski, sill.val = seq(0.0001, 0.001, l = 20),
range.val = seq(0, 20, l = 20), nugget.val = seq(0, 0.001, l = 20)),
uni.only = TRUE)
# ni mi cist jasno kako dolocva sill.val, range.val, nugget.val
# sm zdej popravu tko da so lepsi grafi...ce jst prou razumem so to samo intervali
# na katerih narise grafe
plot(proflik(fit2.ml, geodata = prostorski, sill.val = seq(0.00001, 0.001, l = 20),
range.val = seq(150, 200, l = 10), nugget.val = seq(0, 0.001, l = 20)),
uni.only = TRUE)
# ni mi cist jasno kako dolocva sill.val, range.val, nugget.val
# sm zdej popravu tko da so lepsi grafi...ce jst prou razumem so to samo intervali
# na katerih narise grafe
plot(proflik(fit2.ml, geodata = prostorski, sill.val = seq(0.00001, 0.001, l = 20),
range.val = seq(0, 500, l = 100), nugget.val = seq(0, 0.001, l = 20)),
uni.only = TRUE)
# ni mi cist jasno kako dolocva sill.val, range.val, nugget.val
# sm zdej popravu tko da so lepsi grafi...ce jst prou razumem so to samo intervali
# na katerih narise grafe
plot(proflik(fit2.ml, geodata = prostorski, sill.val = seq(0.00001, 0.001, l = 20),
range.val = seq(150, 200, l = 10), nugget.val = seq(0, 0.001, l = 20)),
uni.only = TRUE)
# ni mi cist jasno kako dolocva sill.val, range.val, nugget.val
# sm zdej popravu tko da so lepsi grafi...ce jst prou razumem so to samo intervali
# na katerih narise grafe
plot(proflik(fit2.ml, geodata = prostorski, sill.val = seq(0.00001, 0.001, l = 20),
range.val = seq(100, 200, l = 30), nugget.val = seq(0, 0.001, l = 20)),
uni.only = TRUE)
par(mfrow = c(1, 3))
# ni mi cist jasno kako dolocva sill.val, range.val, nugget.val
# sm zdej popravu tko da so lepsi grafi...ce jst prou razumem so to samo intervali
# na katerih narise grafe
plot(proflik(fit2.ml, geodata = prostorski, sill.val = seq(0.00001, 0.001, l = 20),
range.val = seq(150, 200, l = 10), nugget.val = seq(0, 0.001, l = 20)),
uni.only = TRUE)
plot(variog1, pch = 16)
lines(fit1.ml, col = "red", lwd = 2)
lines(fit2.ml, col = "green", lwd = 2)
legend("bottomright", col = c("red", "green"), lty = 1, lwd = 2,
legend = c("fit1.ml", "fit2.ml"))
xy.napovedi = data.frame(x=data$vrsta, y=data$lokacija)
nap <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
cov.pars = c(fit1.ml$sigmasq, fit1.ml$phi),
nugget = fit1.ml$nugget, locations = xy.napovedi)
library(lattice)
levelplot(nap$predict ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
contour = FALSE)
xy.napovedi = data.frame(x=data$X, y=data$Y)
nap <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
cov.pars = c(fit1.ml$sigmasq, fit1.ml$phi),
nugget = fit1.ml$nugget, locations = xy.napovedi)
library(lattice)
levelplot(nap$predict ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
contour = FALSE)
nap2 <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
cov.pars = c(fit2.ml$sigmasq, fit2.ml$phi),
nugget = fit2.ml$nugget, locations = xy.napovedi)
levelplot(nap2$predict ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
contour = FALSE)
xy.napovedi = data.frame(x=data$X, y=data$Y)
nap1 <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
cov.pars = c(fit1.ml$sigmasq, fit1.ml$phi),
nugget = fit1.ml$nugget, locations = xy.napovedi)
nap2 <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
cov.pars = c(fit2.ml$sigmasq, fit2.ml$phi),
nugget = fit2.ml$nugget, locations = xy.napovedi)
library(lattice)
par(mfrow=c(1,2))
levelplot(nap$predict ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
contour = FALSE)
levelplot(nap2$predict ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
contour = FALSE)
xy.napovedi = data.frame(x=data$X, y=data$Y)
nap1 <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
cov.pars = c(fit1.ml$sigmasq, fit1.ml$phi),
nugget = fit1.ml$nugget, locations = xy.napovedi)
nap2 <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
cov.pars = c(fit2.ml$sigmasq, fit2.ml$phi),
nugget = fit2.ml$nugget, locations = xy.napovedi)
library(lattice)
par(mfrow=c(1,2))
levelplot(nap$predict ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
contour = FALSE)
levelplot(nap2$predict ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
contour = FALSE)
# Gaussov model variograma brez zlatega zrna
variogram2 <- variog(prostorski, max.dist = 180)
initial.values <- expand.grid(seq(4e-04, 8e-04, l=20), seq(40, 140, by = 20))
fit1_g <- variofit(variogram1, cov.model = "gaussian",
ini.cov.pars = initial.values,
fix.nugget = TRUE, nugget = 0, max.dist = 180,
weights = "npairs")
fit1_g.ml <- likfit(prostorski, ini.cov.pars = fit1, cov.model = "gaussian",
fix.nugget = TRUE, lik.met = "ML")
fit1_g.ml
par(mfrow = c(1, 2))
# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1_g.ml, geodata = prostorski,
sill.val = seq(0.0001, 0.0015, l = 20),
range.val = seq(0.1, 5, l = 12), uni.only = TRUE))
# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1_g.ml, geodata = prostorski,
sill.val = seq(0.0001, 0.0015, l = 20),
range.val = seq(15, 40, l = 12), uni.only = TRUE))
# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1_g.ml, geodata = prostorski,
sill.val = seq(0.0001, 0.0015, l = 20),
range.val = seq(15, 30, l = 12), uni.only = TRUE))
# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1_g.ml, geodata = prostorski,
sill.val = seq(0.0001, 0.0015, l = 20),
range.val = seq(15, 30, l = 5), uni.only = TRUE))
plot(variogram2, pch = 16)
lines(fit1_g, col = "red", lwd = 2)
lines(fit1_g.ml, col = "green", lwd = 2)
legend("bottomright", col = c("red", "green"), lty = 1, lwd = 2,
legend = c("fit1", "fit1.ml"))
# za oceno parametrov semivariograma z ML, ki za začetne vrednosti vzame
# ocene dobljene s funkcijo variofit fit1, ki ocenjuje tudi zlato zrno
fit2_g.ml <- likfit(prostorski, ini.cov.pars = fit1_g, cov.model = "gaussian",
fix.nugget = FALSE, lik.met = "ML")  # fix.nugget = FALSE
fit2_g.ml
# # ni mi cist jasno kako dolocva sill.val, range.val, nugget.val
# # sm zdej popravu tko da so lepsi grafi...ce jst prou razumem so to samo intervali
# # na katerih narise grafe
plot(proflik(fit2_g.ml, geodata = prostorski, sill.val = seq(0.0001, 0.001, l = 20),
range.val = seq(0, 20, l = 20), nugget.val = seq(0, 0.001, l = 20)),
uni.only = TRUE)
# # ni mi cist jasno kako dolocva sill.val, range.val, nugget.val
# # sm zdej popravu tko da so lepsi grafi...ce jst prou razumem so to samo intervali
# # na katerih narise grafe
plot(proflik(fit2_g.ml, geodata = prostorski, sill.val = seq(0.00001, 0.01, l = 20),
range.val = seq(15, 35, l = 20), nugget.val = seq(0, 0.001, l = 20)),
uni.only = TRUE)
# # ni mi cist jasno kako dolocva sill.val, range.val, nugget.val
# # sm zdej popravu tko da so lepsi grafi...ce jst prou razumem so to samo intervali
# # na katerih narise grafe
plot(proflik(fit2_g.ml, geodata = prostorski, sill.val = seq(0.00001, 0.002, l = 20),
range.val = seq(15, 35, l = 20), nugget.val = seq(0, 0.001, l = 20)),
uni.only = TRUE)
plot(variog1, pch = 16)
lines(fit1_g.ml, col = "red", lwd = 2)
lines(fit2_g.ml, col = "green", lwd = 2)
legend("bottomright", col = c("red", "green"), lty = 1, lwd = 2,
legend = c("fit1.ml", "fit2.ml"))
xy.napovedi = data.frame(x=data$X, y=data$Y)
nap <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "gaussian",
cov.pars = c(fit1_g.ml$sigmasq, fit1_g.ml$phi),
nugget = fit1_g.ml$nugget, locations = xy.napovedi)
library(lattice)
levelplot(nap$predict ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
contour = FALSE)
xy.napovedi = data.frame(x=data$X, y=data$Y)
nap1 <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
cov.pars = c(fit1.ml$sigmasq, fit1.ml$phi),
nugget = fit1.ml$nugget, locations = xy.napovedi)
nap2 <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
cov.pars = c(fit2.ml$sigmasq, fit2.ml$phi),
nugget = fit2.ml$nugget, locations = xy.napovedi)
library(lattice)
par(mfrow=c(1,2))
levelplot(nap1$predict ~ nap1$locations[,1] + nap1$locations[,2], nap1, aspect = "fill",
contour = FALSE)
levelplot(nap2$predict ~ nap2$locations[,1] + nap2$locations[,2], nap2, aspect = "fill",
contour = FALSE)
levelplot(sqrt(nap$krige.var) ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
contour = FALSE, xlab = "X", ylab = "Y")
xy.napovedi = data.frame(x=data$X, y=data$Y)
nap <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "gaussian",
cov.pars = c(fit2_g.ml$sigmasq, fit2_g.ml$phi),
nugget = fit2_g.ml$nugget, locations = xy.napovedi)
library(lattice)
levelplot(nap$predict ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
contour = FALSE, xlab = "X", ylab = "Y")
levelplot(sqrt(nap$krige.var) ~ nap$locations[,1] + nap$locations[,2], nap, aspect = "fill",
contour = FALSE, xlab = "X", ylab = "Y")
knitr::opts_chunk$set(echo = FALSE, fig.pos = "H", out.extra = "", fig.height = 4, fig.width = 5, fig.align = 'center', warning = F)
# install.packages("readxl")
library(readxl)
library(astsa)
library(car)
library(splines)
library(geoR)
library(gstat)
library(sp)
library(raster)
library(lattice)
library(kableExtra)
library(ggplot2)
library(tidyr)
library(gridExtra)
par(mfrow=c(1,1))
levelplot(nap2$predict ~ nap2$locations[,1] + nap2$locations[,2], nap2, aspect = "fill",
contour = FALSE, xlab = "X", ylab = "Y")
levelplot(sqrt(nap2$krige.var) ~ nap2$locations[,1] + nap2$locations[,2], nap2, aspect = "fill",
contour = FALSE, xlab = "X", ylab = "Y")
xy.napovedi = data.frame(x=data$X, y=data$Y)
nap1 <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
cov.pars = c(fit1.ml$sigmasq, fit1.ml$phi),
nugget = fit1.ml$nugget, locations = xy.napovedi)
nap2 <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
cov.pars = c(fit2.ml$sigmasq, fit2.ml$phi),
nugget = fit2.ml$nugget, locations = xy.napovedi)
par(mfrow=c(1,2))
levelplot(nap1$predict ~ nap1$locations[,1] + nap1$locations[,2], nap1, aspect = "fill",
contour = FALSE, xlab = "X", ylab = "Y")
levelplot(sqrt(nap1$krige.var) ~ nap1$locations[,1] + nap1$locations[,2], nap1, aspect = "fill",
contour = FALSE, xlab = "X", ylab = "Y")
par(mfrow=c(1,1))
levelplot(nap2$predict ~ nap2$locations[,1] + nap2$locations[,2], nap2, aspect = "fill",
contour = FALSE, xlab = "X", ylab = "Y")
levelplot(sqrt(nap2$krige.var) ~ nap2$locations[,1] + nap2$locations[,2], nap2, aspect = "fill",
contour = FALSE, xlab = "X", ylab = "Y")
knitr::opts_chunk$set(echo = FALSE, fig.pos = "H", out.extra = "", fig.height = 4, fig.width = 5, fig.align = 'center', warning = F)
# install.packages("readxl")
library(readxl)
library(astsa)
library(car)
library(splines)
library(geoR)
library(gstat)
library(sp)
library(raster)
library(lattice)
library(kableExtra)
library(ggplot2)
library(tidyr)
library(gridExtra)
# mogoce tudi library(raster)
par(mfrow = c(1, 2))
# plot(proflik(fit1.ml, geodata = prostorski, sill.val = seq(10, 70, l = 20),
#              range.val = seq(1, 10, l = 12), uni.only = TRUE))
# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1_g.ml, geodata = prostorski,
sill.val = seq(0.0001, 0.0015, l = 20),
range.val = seq(15, 30, l = 5), uni.only = TRUE))
par(mfrow = c(1, 2))
# plot(proflik(fit1.ml, geodata = prostorski, sill.val = seq(10, 70, l = 20),
#              range.val = seq(1, 10, l = 12), uni.only = TRUE))
# sill.val pomeni interval sigma^2
# range.val interval za phi
plot(proflik(fit1.ml, geodata = prostorski, sill.val = seq(0.00001, 0.003, l = 20),
range.val = seq(0.1, 100, l = 20), uni.only = TRUE))
xy.napovedi = data.frame(x=data$X, y=data$Y)
nap1 <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
cov.pars = c(fit1.ml$sigmasq, fit1.ml$phi),
nugget = fit1.ml$nugget, locations = xy.napovedi)
nap2 <- ksline(prostorski, trend = ~coords[,1] * coords[,2], cov.model = "sph",
cov.pars = c(fit2.ml$sigmasq, fit2.ml$phi),
nugget = fit2.ml$nugget, locations = xy.napovedi)
par(mfrow=c(2,1))
levelplot(nap1$predict ~ nap1$locations[,1] + nap1$locations[,2], nap1, aspect = "fill",
contour = FALSE, xlab = "X", ylab = "Y")
levelplot(sqrt(nap1$krige.var) ~ nap1$locations[,1] + nap1$locations[,2], nap1, aspect = "fill",
contour = FALSE, xlab = "X", ylab = "Y")
