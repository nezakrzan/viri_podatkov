pairs(data.primer2[,1:4], col=data.primer2[,9])
set.seed(2024)
########################## generiranje podatkov #############################
# funkcija za generiranje podatkov
generiranje.podatkov = function(stevilo.spremenljivk, velikost.skupin, stevilo.skupin, diff){
# generiranje povprečij
M = diag(stevilo.skupin)*diff
# neinformativne spremenljivke - same 0
M = cbind(M, matrix(0, nrow=stevilo.skupin, ncol=stevilo.spremenljivk-stevilo.skupin))
S = diag(stevilo.spremenljivk)
X = NULL
# generamo podatke za vsako skupino posebaj
for(i in 1:stevilo.skupin){
iX = MASS::mvrnorm(n=velikost.skupin, mu = M[i,], Sigma = S)
X = rbind(X,iX)
}
# dodamo se skupino
X = cbind(X, skupina=rep(1:stevilo.skupin,each=velikost.skupin)) # clu = skupina
return(X)
}
################################## simulacija ##################################
st.ponovitev = 5
stevilo.skupin.v = c(4, 8, 10)
velikost.skupin.v = c(20, 100, 200)
stevilo.spremenljivk.v = c(8, 16, 32)
diff.v = c(0.5, 1, 2, 10)
stevilo.zacetnih.skupin = c(1, 4, 10, 100)
settings = expand.grid(stevilo.spremenljivk = rev(stevilo.spremenljivk.v),
velikost.skupin = rev(velikost.skupin.v),
stevilo.skupin=rev(stevilo.skupin.v),
diff = rev(diff.v))
useOld = FALSE # ne uporabljal starega rezultata
if(useOld&&file.exists("simulacija.RDS")){
res = readRDS("simulacija.RDS")
}else{
# potrebne knjiznice
library(foreach)
library(doParallel)
library(doRNG)
# parallel computing
nc = detectCores()-1
cl = makeCluster(nc, outfile="logSimulacija") # shranjujemo konzolo
registerDoParallel(cl)
set.seed(2024)
timePar = system.time({ # za time
res = foreach(i = 1:nrow(settings), .combine=rbind) %dorng% {
# izberemo faktorje
stevilo.spremenljivk = settings$stevilo.spremenljivk[i]
stevilo.skupin = settings$stevilo.skupin[i]
velikost.skupin = settings$velikost.skupin[i]
diff = settings$diff[i]
# za rezultate
res = data.frame(settings[rep(i,m*length(kMeansRep)),], id=NA, nRep=NA, ari=NA, wss=NA, pwss=NA)
# pazi da bodo pravi podatki v pravi vrstici
ind = 0
for(j in 1:m){
# generiramo podatke
data = generiranje.podatkov(stevilo.spremenljivk= stevilo.spremenljivk,
velikost.skupin = velikost.skupin,
stevilo.skupin = stevilo.skupin,
diff = diff)
# transformacija v data.frame
data = as.data.frame(data)
# najprej sm nardila sam za eno metodo
for(nRep in stevilo.zacetnih.skupin){
# metoda kmeans
kmeans.res = kmeans(dat[,1:stevilo.spremenljivk], centers=stevilo.skupin, nstart=nRep)
# zapis v pravo vrstico
ind = ind+1
res$id[ind] = i*m*10 + j
res$nRep[ind] = nRep
# mere
res$ari[ind] = blockmodeling::crand(dat$skupina, kmeans.res$cluster) #prava vrednost in vrednost iz rezultatov
res$wss[ind] = kmeans.res$tot.withinss
res$pwss[ind] = kmeans.res$tot.withinss/kmeans.res$totss
}
}
cat("Setting ",i,"/",nrow(settings), " done.\t", format(Sys.time()) ,"\n", sep="")
return(res)
}
})
attr(res, "time") = timePar
cat("Time needed in min:", timePar[3]/60, "\n")
saveRDS(res, "simulacija.RDS")
stopCluster(cl)
}
################################## simulacija ##################################
m = 5 # st. ponovitev
stevilo.skupin.v = c(4, 8, 10)
velikost.skupin.v = c(20, 100, 200)
stevilo.spremenljivk.v = c(8, 16, 32)
diff.v = c(0.5, 1, 2, 10)
stevilo.zacetnih.skupin = c(1, 4, 10, 100)
settings = expand.grid(stevilo.spremenljivk = rev(stevilo.spremenljivk.v),
velikost.skupin = rev(velikost.skupin.v),
stevilo.skupin=rev(stevilo.skupin.v),
diff = rev(diff.v))
useOld = FALSE # ne uporabljal starega rezultata
if(useOld&&file.exists("simulacija.RDS")){
res = readRDS("simulacija.RDS")
}else{
# potrebne knjiznice
library(foreach)
library(doParallel)
library(doRNG)
# parallel computing
nc = detectCores()-1
cl = makeCluster(nc, outfile="logSimulacija") # shranjujemo konzolo
registerDoParallel(cl)
set.seed(2024)
timePar = system.time({ # za time
res = foreach(i = 1:nrow(settings), .combine=rbind) %dorng% {
# izberemo faktorje
stevilo.spremenljivk = settings$stevilo.spremenljivk[i]
stevilo.skupin = settings$stevilo.skupin[i]
velikost.skupin = settings$velikost.skupin[i]
diff = settings$diff[i]
# za rezultate
res = data.frame(settings[rep(i,m*length(kMeansRep)),], id=NA, nRep=NA, ari=NA, wss=NA, pwss=NA)
# pazi da bodo pravi podatki v pravi vrstici
ind = 0
for(j in 1:m){
# generiramo podatke
data = generiranje.podatkov(stevilo.spremenljivk= stevilo.spremenljivk,
velikost.skupin = velikost.skupin,
stevilo.skupin = stevilo.skupin,
diff = diff)
# transformacija v data.frame
data = as.data.frame(data)
# najprej sm nardila sam za eno metodo
for(nRep in stevilo.zacetnih.skupin){
# metoda kmeans
kmeans.res = kmeans(dat[,1:stevilo.spremenljivk], centers=stevilo.skupin, nstart=nRep)
# zapis v pravo vrstico
ind = ind+1
res$id[ind] = i*m*10 + j
res$nRep[ind] = nRep
# mere
res$ari[ind] = blockmodeling::crand(dat$skupina, kmeans.res$cluster) #prava vrednost in vrednost iz rezultatov
res$wss[ind] = kmeans.res$tot.withinss
res$pwss[ind] = kmeans.res$tot.withinss/kmeans.res$totss
}
}
cat("Setting ",i,"/",nrow(settings), " done.\t", format(Sys.time()) ,"\n", sep="")
return(res)
}
})
attr(res, "time") = timePar
cat("Time needed in min:", timePar[3]/60, "\n")
saveRDS(res, "simulacija.RDS")
stopCluster(cl)
}
################################## simulacija ##################################
m = 5 # st. ponovitev
stevilo.skupin.v = c(4, 8, 10)
velikost.skupin.v = c(20, 100, 200)
stevilo.spremenljivk.v = c(8, 16, 32)
diff.v = c(0.5, 1, 2, 10)
stevilo.zacetnih.skupin = c(1, 4, 10, 100)
settings = expand.grid(stevilo.spremenljivk = rev(stevilo.spremenljivk.v),
velikost.skupin = rev(velikost.skupin.v),
stevilo.skupin=rev(stevilo.skupin.v),
diff = rev(diff.v))
useOld = FALSE # ne uporabljal starega rezultata
if(useOld&&file.exists("simulacija.RDS")){
res = readRDS("simulacija.RDS")
}else{
# potrebne knjiznice
library(foreach)
library(doParallel)
library(doRNG)
# parallel computing
nc = detectCores()-1
cl = makeCluster(nc, outfile="logSimulacija") # shranjujemo konzolo
registerDoParallel(cl)
set.seed(2024)
timePar = system.time({ # za time
res = foreach(i = 1:nrow(settings), .combine=rbind) %dorng% {
# izberemo faktorje
stevilo.spremenljivk = settings$stevilo.spremenljivk[i]
stevilo.skupin = settings$stevilo.skupin[i]
velikost.skupin = settings$velikost.skupin[i]
diff = settings$diff[i]
# za rezultate
res = data.frame(settings[rep(i,m*length(stevilo.zacetnih.skupin)),], id=NA, nRep=NA, ari=NA, wss=NA, pwss=NA)
# pazi da bodo pravi podatki v pravi vrstici
ind = 0
for(j in 1:m){
# generiramo podatke
data = generiranje.podatkov(stevilo.spremenljivk= stevilo.spremenljivk,
velikost.skupin = velikost.skupin,
stevilo.skupin = stevilo.skupin,
diff = diff)
# transformacija v data.frame
data = as.data.frame(data)
# najprej sm nardila sam za eno metodo
for(nRep in stevilo.zacetnih.skupin){
# metoda kmeans
kmeans.res = kmeans(dat[,1:stevilo.spremenljivk], centers=stevilo.skupin, nstart=nRep)
# zapis v pravo vrstico
ind = ind+1
res$id[ind] = i*m*10 + j
res$nRep[ind] = nRep
# mere
res$ari[ind] = blockmodeling::crand(dat$skupina, kmeans.res$cluster) #prava vrednost in vrednost iz rezultatov
res$wss[ind] = kmeans.res$tot.withinss
res$pwss[ind] = kmeans.res$tot.withinss/kmeans.res$totss
}
}
cat("Setting ",i,"/",nrow(settings), " done.\t", format(Sys.time()) ,"\n", sep="")
return(res)
}
})
attr(res, "time") = timePar
cat("Time needed in min:", timePar[3]/60, "\n")
saveRDS(res, "simulacija.RDS")
stopCluster(cl)
}
################################## simulacija ##################################
m = 5 # st. ponovitev
stevilo.skupin.v = c(4, 8, 10)
velikost.skupin.v = c(20, 100, 200)
stevilo.spremenljivk.v = c(8, 16, 32)
diff.v = c(0.5, 1, 2, 10)
stevilo.zacetnih.skupin = c(1, 4, 10, 100)
settings = expand.grid(stevilo.spremenljivk = rev(stevilo.spremenljivk.v),
velikost.skupin = rev(velikost.skupin.v),
stevilo.skupin=rev(stevilo.skupin.v),
diff = rev(diff.v))
useOld = FALSE # ne uporabljal starega rezultata
if(useOld&&file.exists("simulacija.RDS")){
res = readRDS("simulacija.RDS")
}else{
# potrebne knjiznice
library(foreach)
library(doParallel)
library(doRNG)
# parallel computing
nc = detectCores()-1
cl = makeCluster(nc, outfile="logSimulacija") # shranjujemo konzolo
registerDoParallel(cl)
set.seed(2024)
timePar = system.time({ # za time
res = foreach(i = 1:nrow(settings), .combine=rbind) %dorng% {
# izberemo faktorje
stevilo.spremenljivk = settings$stevilo.spremenljivk[i]
stevilo.skupin = settings$stevilo.skupin[i]
velikost.skupin = settings$velikost.skupin[i]
diff = settings$diff[i]
# za rezultate
res = data.frame(settings[rep(i,m*length(stevilo.zacetnih.skupin)),], id=NA, nRep=NA, ari=NA, wss=NA, pwss=NA)
# pazi da bodo pravi podatki v pravi vrstici
ind = 0
for(j in 1:m){
# generiramo podatke
data = generiranje.podatkov(stevilo.spremenljivk= stevilo.spremenljivk,
velikost.skupin = velikost.skupin,
stevilo.skupin = stevilo.skupin,
diff = diff)
# transformacija v data.frame
data = as.data.frame(data)
# najprej sm nardila sam za eno metodo
for(nRep in stevilo.zacetnih.skupin){
# metoda kmeans
kmeans.res = kmeans(data[,1:stevilo.spremenljivk], centers=stevilo.skupin, nstart=nRep)
# zapis v pravo vrstico
ind = ind+1
res$id[ind] = i*m*10 + j
res$nRep[ind] = nRep
# mere
res$ari[ind] = blockmodeling::crand(data$skupina, kmeans.res$cluster) #prava vrednost in vrednost iz rezultatov
res$wss[ind] = kmeans.res$tot.withinss
res$pwss[ind] = kmeans.res$tot.withinss/kmeans.res$totss
}
}
cat("Setting ",i,"/",nrow(settings), " done.\t", format(Sys.time()) ,"\n", sep="")
return(res)
}
})
attr(res, "time") = timePar
cat("Time needed in min:", timePar[3]/60, "\n")
saveRDS(res, "simulacija.RDS")
stopCluster(cl)
}
################################## simulacija ##################################
m = 5 # st. ponovitev
stevilo.skupin.v = c(4, 8, 10)
velikost.skupin.v = c(20, 100, 200)
stevilo.spremenljivk.v = c(10, 20, 30)
diff.v = c(0.5, 1, 2, 10)
stevilo.zacetnih.skupin = c(1, 4, 10, 100)
settings = expand.grid(stevilo.spremenljivk = rev(stevilo.spremenljivk.v),
velikost.skupin = rev(velikost.skupin.v),
stevilo.skupin=rev(stevilo.skupin.v),
diff = rev(diff.v))
useOld = FALSE # ne uporabljal starega rezultata
if(useOld&&file.exists("simulacija.RDS")){
res = readRDS("simulacija.RDS")
}else{
# potrebne knjiznice
library(foreach)
library(doParallel)
library(doRNG)
# parallel computing
nc = detectCores()-1
cl = makeCluster(nc, outfile="logSimulacija") # shranjujemo konzolo
registerDoParallel(cl)
set.seed(2024)
timePar = system.time({ # za time
res = foreach(i = 1:nrow(settings), .combine=rbind) %dorng% {
# izberemo faktorje
stevilo.spremenljivk = settings$stevilo.spremenljivk[i]
stevilo.skupin = settings$stevilo.skupin[i]
velikost.skupin = settings$velikost.skupin[i]
diff = settings$diff[i]
# za rezultate
res = data.frame(settings[rep(i,m*length(stevilo.zacetnih.skupin)),], id=NA, nRep=NA, ari=NA, wss=NA, pwss=NA)
# pazi da bodo pravi podatki v pravi vrstici
ind = 0
for(j in 1:m){
# generiramo podatke
data = generiranje.podatkov(stevilo.spremenljivk= stevilo.spremenljivk,
velikost.skupin = velikost.skupin,
stevilo.skupin = stevilo.skupin,
diff = diff)
# transformacija v data.frame
data = as.data.frame(data)
# najprej sm nardila sam za eno metodo
for(nRep in stevilo.zacetnih.skupin){
# metoda kmeans
kmeans.res = kmeans(data[,1:stevilo.spremenljivk], centers=stevilo.skupin, nstart=nRep)
# zapis v pravo vrstico
ind = ind+1
res$id[ind] = i*m*10 + j
res$nRep[ind] = nRep
# mere
res$ari[ind] = blockmodeling::crand(data$skupina, kmeans.res$cluster) #prava vrednost in vrednost iz rezultatov
res$wss[ind] = kmeans.res$tot.withinss
res$pwss[ind] = kmeans.res$tot.withinss/kmeans.res$totss
}
}
cat("Setting ",i,"/",nrow(settings), " done.\t", format(Sys.time()) ,"\n", sep="")
return(res)
}
})
attr(res, "time") = timePar
cat("Time needed in min:", timePar[3]/60, "\n")
saveRDS(res, "simulacija.RDS")
stopCluster(cl)
}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center", fig.pos = "H", message = FALSE, warning = FALSE, results = F, fig.height =3, fig.width = 6.5)
# potrebne knjižnice
library(ggplot2)
library(car)
library(tidyr)
library(ADGofTest)
# seme
set.seed(2024)
generiranje.podatkov = function(stevilo.spremenljivk, velikost.skupin, stevilo.skupin, diff){
# generiranje povprečij
M = diag(stevilo.skupin)*diff
# neinformativne spremenljivke - same 0
M = cbind(M, matrix(0, nrow=stevilo.skupin, ncol=stevilo.spremenljivk-stevilo.skupin))
S = diag(stevilo.spremenljivk)
X = NULL
# generamo podatke za vsako skupino posebaj
for(i in 1:stevilo.skupin){
iX = MASS::mvrnorm(n=velikost.skupin, mu = M[i,], Sigma = S)
X = rbind(X,iX)
}
# dodamo se skupino
X = cbind(X, skupina=rep(1:stevilo.skupin,each=velikost.skupin)) # clu = skupina
return(X)
}
data.primer1 = generiranje.podatkov(stevilo.spremenljivk = 12, velikost.skupin = 100, stevilo.skupin = 4, diff = 2)
data.primer1
setwd("~/Documents/viri_podatkov/racunsko_zahtevne_metode/02_naloga")
knitr::opts_chunk$set(echo = FALSE, fig.align = "center", fig.pos = "H", message = FALSE, warning = FALSE, results = F, fig.height =3, fig.width = 6.5)
# potrebne knjižnice
library(ggplot2)
library(car)
library(tidyr)
library(dplyr)
library(ADGofTest)
# seme
set.seed(2024)
generiranje.podatkov = function(stevilo.spremenljivk, velikost.skupin, stevilo.skupin, diff){
# generiranje povprečij
M = diag(stevilo.skupin)*diff
# neinformativne spremenljivke - same 0
M = cbind(M, matrix(0, nrow=stevilo.skupin, ncol=stevilo.spremenljivk-stevilo.skupin))
S = diag(stevilo.spremenljivk)
X = NULL
# generamo podatke za vsako skupino posebaj
for(i in 1:stevilo.skupin){
iX = MASS::mvrnorm(n=velikost.skupin, mu = M[i,], Sigma = S)
X = rbind(X,iX)
}
# dodamo se skupino
X = cbind(X, skupina=rep(1:stevilo.skupin,each=velikost.skupin)) # clu = skupina
return(X)
}
data.primer1 = generiranje.podatkov(stevilo.spremenljivk = 12, velikost.skupin = 100, stevilo.skupin = 4, diff = 2)
pairs(data.primer1[,1:4], col=data.primer1[,13])
data.primer2 = generiranje.podatkov(stevilo.spremenljivk = 12, velikost.skupin = 100, stevilo.skupin = 4, diff = 4)
pairs(data.primer2[,1:4], col=data.primer2[,13])
res = readRDS("simulacija.RDS")
resLong = pivot_longer(res, cols =matches("^(ari|wss|pwss)\\."),
values_to = "value",
names_to = c("metric", "method"),
names_pattern = "^(ari|wss|pwss)\\.(kmeans|mclust)")
resLong$method[resLong$method == "kmeans"] = "metoda voditeljev"
resLong$method[resLong$method == "mclust"] = "razvrščanje na podlagi modelov"
resWide <- resLong %>% pivot_wider(names_from = metric, values_from = value) # da so ari, wss in pwss vsaka svoj column
resAgg = aggregate(cbind(ari, wss, pwss) ~ stevilo.spremenljivk + velikost.skupin
+ stevilo.skupin + method,
data = resWide, FUN = mean)
resAggFac = resAgg
resAggFac$stevilo.spremenljivk = as.factor(resAggFac$stevilo.spremenljivk)
resAggFac$velikost.skupin = as.factor(resAggFac$velikost.skupin)
resAggFac$stevilo.skupin = as.factor(resAggFac$stevilo.skupin)
resAgg_diff = aggregate(cbind(ari, wss, pwss) ~ stevilo.spremenljivk +
velikost.skupin + stevilo.skupin + method + diff,
data = resWide, FUN = mean)
resAggFac_diff = resAgg_diff
resAggFac_diff$stevilo.spremenljivk = as.factor(resAggFac_diff$stevilo.spremenljivk)
resAggFac_diff$velikost.skupin = as.factor(resAggFac_diff$velikost.skupin)
resAggFac_diff$stevilo.skupin = as.factor(resAggFac_diff$stevilo.skupin)
resAggFac_diff$diff = as.factor(resAggFac_diff$diff)
ggplot(resAggFac, aes(y = ari, x = stevilo.spremenljivk,
col=method, group=method)) +
geom_point() + geom_line() +
facet_grid(stevilo.skupin ~ velikost.skupin, scales="free") +
xlab("stevilo spremenljivk") +
ylab("ARI") +
theme_minimal() +
labs(color = "Metoda:") +
theme(legend.position = "bottom")
ggplot(resAggFac, aes(y = ari, x = velikost.skupin,
col=method, group=method)) +
geom_point() + geom_line() +
facet_grid(stevilo.skupin ~ stevilo.spremenljivk, scales="free") +
xlab("velikost skupin") +
ylab("ARI") +
theme_minimal() +
labs(color = "Metoda:") +
theme(legend.position = "bottom")
ggplot(resAggFac_diff, aes(y = ari, x = stevilo.spremenljivk,
col=method, group=interaction(method, diff), linetype=diff)) +
geom_point() + geom_line() +
scale_linetype_manual(values=c("dotted", "dotdash", "dashed", "solid"))+
facet_grid(stevilo.skupin ~ velikost.skupin, scales="free")+
xlab("stevilo spremenljivk") +
ylab("ARI") +
theme_minimal() +
labs(color = "Metoda:")
resAggFac_diff
resAggFac_diff_12 <- resAggFac_diff %>%
filter(diff %in% c(1, 2))
ggplot(resAggFac_diff_12, aes(y = ari, x = stevilo.spremenljivk,
col=method, group=interaction(method, diff), linetype=diff)) +
geom_point() + geom_line() +
scale_linetype_manual(values=c("dotted", "dotdash", "dashed", "solid"))+
facet_grid(stevilo.skupin ~ velikost.skupin, scales="free")+
xlab("stevilo spremenljivk") +
ylab("ARI") +
theme_minimal() +
labs(color = "Metoda:")
resAggFac_diff_12 <- resAggFac_diff %>%
filter(diff %in% c(1, 2))
ggplot(resAggFac_diff_12, aes(y = ari, x = stevilo.spremenljivk,
col=method, group=interaction(method, diff), linetype=diff)) +
geom_point() + geom_line() +
scale_linetype_manual(values=c("dotted", "dotdash", "dashed", "solid"))+
facet_grid(stevilo.skupin ~ velikost.skupin, scales="free")+
xlab("stevilo spremenljivk") +
ylab("ARI") +
theme_minimal() +
labs(color = "Metoda:") + theme(legend.position = "bottom")
resAggFac_diff_12 <- resAggFac_diff %>%
filter(diff %in% c(1, 2))
ggplot(resAggFac_diff_12, aes(y = ari, x = stevilo.spremenljivk,
col=method, group=interaction(method, diff), linetype=diff)) +
geom_point() + geom_line() +
scale_linetype_manual(values=c("dotted", "solid"))+
facet_grid(stevilo.skupin ~ velikost.skupin, scales="free")+
xlab("stevilo spremenljivk") +
ylab("ARI") +
theme_minimal() +
labs(color = "Metoda:") + theme(legend.position = "bottom")
resAggFac_diff_12 <- resAggFac_diff %>%
filter(diff %in% c(1, 2))
ggplot(resAggFac_diff_12, aes(y = ari, x = velikost.skupin,
col=method, group=interaction(method, diff), linetype=diff)) +
geom_point() + geom_line() +
scale_linetype_manual(values=c("dotted", "solid"))+
facet_grid(stevilo.spremenljivk ~ stevilo.skupin, scales="free")+
xlab("stevilo spremenljivk") +
ylab("ARI") +
theme_minimal() +
labs(color = "Metoda:") + theme(legend.position = "bottom")
resAggFac_diff_24 <- resAggFac_diff %>%
filter(diff %in% c(2, 4))
ggplot(resAggFac_diff_24, aes(y = ari, x = velikost.skupin,
col=method, group=interaction(method, diff), linetype=diff)) +
geom_point() + geom_line() +
scale_linetype_manual(values=c("dotted", "solid"))+
facet_grid(stevilo.spremenljivk ~ stevilo.skupin, scales="free")+
xlab("stevilo spremenljivk") +
ylab("ARI") +
theme_minimal() +
labs(color = "Metoda:") + theme(legend.position = "bottom")
