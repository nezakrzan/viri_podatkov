for(i in 1:stevilo.skupin){
iX = MASS::mvrnorm(n=velikost.skupin, mu = M[i,], Sigma = S)
X = rbind(X,iX)
}
# dodamo se skupino
X = cbind(X, skupina=rep(1:stevilo.skupin,each=velikost.skupin)) # clu = skupina
return(X)
}
data.primer1 = generiranje.podatkov(stevilo.spremenljivk = 8, velikost.skupin = 100, stevilo.skupin = 4, diff = 2)
data.primer2 = generiranje.podatkov(stevilo.spremenljivk = 8, velikost.skupin = 100, stevilo.skupin = 4, diff = 10)
par(mfrow(2))
par(mfrow(c(1,2)))
data.primer1 = generiranje.podatkov(stevilo.spremenljivk = 8, velikost.skupin = 100, stevilo.skupin = 4, diff = 2)
data.primer2 = generiranje.podatkov(stevilo.spremenljivk = 8, velikost.skupin = 100, stevilo.skupin = 4, diff = 10)
par(mfrow=c(1,2))
pairs(data.primer1[,1:4], col=data.primer1[,9])
pairs(data.primer2[,1:4], col=data.primer2[,9])
par(mfrow=c(1,2))
pairs(data.primer1[,1:4], col=data.primer1[,9])
pairs(data.primer2[,1:4], col=data.primer2[,9])
set.seed(2024)
########################## generiranje podatkov #############################
# funkcija za generiranje podatkov
generiranje.podatkov = function(stevilo.spremenljivk, velikost.skupin, stevilo.skupin, diff){
# generiranje povprečij
M = diag(stevilo.skupin)*diff
# neinformativne spremenljivke - same 0
M = cbind(M, matrix(0, nrow=stevilo.skupin, ncol=stevilo.spremenljivk-stevilo.skupin))
S = diag(stevilo.spremenljivk)
X = NULL
# generamo podatke za vsako skupino posebaj
for(i in 1:stevilo.skupin){
iX = MASS::mvrnorm(n=velikost.skupin, mu = M[i,], Sigma = S)
X = rbind(X,iX)
}
# dodamo se skupino
X = cbind(X, skupina=rep(1:stevilo.skupin,each=velikost.skupin)) # clu = skupina
return(X)
}
################################## simulacija ##################################
st.ponovitev = 5
stevilo.skupin.v = c(4, 8, 10)
velikost.skupin.v = c(20, 100, 200)
stevilo.spremenljivk.v = c(8, 16, 32)
diff.v = c(0.5, 1, 2, 10)
stevilo.zacetnih.skupin = c(1, 4, 10, 100)
settings = expand.grid(stevilo.spremenljivk = rev(stevilo.spremenljivk.v),
velikost.skupin = rev(velikost.skupin.v),
stevilo.skupin=rev(stevilo.skupin.v),
diff = rev(diff.v))
useOld = FALSE # ne uporabljal starega rezultata
if(useOld&&file.exists("simulacija.RDS")){
res = readRDS("simulacija.RDS")
}else{
# potrebne knjiznice
library(foreach)
library(doParallel)
library(doRNG)
# parallel computing
nc = detectCores()-1
cl = makeCluster(nc, outfile="logSimulacija") # shranjujemo konzolo
registerDoParallel(cl)
set.seed(2024)
timePar = system.time({ # za time
res = foreach(i = 1:nrow(settings), .combine=rbind) %dorng% {
# izberemo faktorje
stevilo.spremenljivk = settings$stevilo.spremenljivk[i]
stevilo.skupin = settings$stevilo.skupin[i]
velikost.skupin = settings$velikost.skupin[i]
diff = settings$diff[i]
# za rezultate
res = data.frame(settings[rep(i,m*length(kMeansRep)),], id=NA, nRep=NA, ari=NA, wss=NA, pwss=NA)
# pazi da bodo pravi podatki v pravi vrstici
ind = 0
for(j in 1:m){
# generiramo podatke
data = generiranje.podatkov(stevilo.spremenljivk= stevilo.spremenljivk,
velikost.skupin = velikost.skupin,
stevilo.skupin = stevilo.skupin,
diff = diff)
# transformacija v data.frame
data = as.data.frame(data)
# najprej sm nardila sam za eno metodo
for(nRep in stevilo.zacetnih.skupin){
# metoda kmeans
kmeans.res = kmeans(dat[,1:stevilo.spremenljivk], centers=stevilo.skupin, nstart=nRep)
# zapis v pravo vrstico
ind = ind+1
res$id[ind] = i*m*10 + j
res$nRep[ind] = nRep
# mere
res$ari[ind] = blockmodeling::crand(dat$skupina, kmeans.res$cluster) #prava vrednost in vrednost iz rezultatov
res$wss[ind] = kmeans.res$tot.withinss
res$pwss[ind] = kmeans.res$tot.withinss/kmeans.res$totss
}
}
cat("Setting ",i,"/",nrow(settings), " done.\t", format(Sys.time()) ,"\n", sep="")
return(res)
}
})
attr(res, "time") = timePar
cat("Time needed in min:", timePar[3]/60, "\n")
saveRDS(res, "simulacija.RDS")
stopCluster(cl)
}
################################## simulacija ##################################
m = 5 # st. ponovitev
stevilo.skupin.v = c(4, 8, 10)
velikost.skupin.v = c(20, 100, 200)
stevilo.spremenljivk.v = c(8, 16, 32)
diff.v = c(0.5, 1, 2, 10)
stevilo.zacetnih.skupin = c(1, 4, 10, 100)
settings = expand.grid(stevilo.spremenljivk = rev(stevilo.spremenljivk.v),
velikost.skupin = rev(velikost.skupin.v),
stevilo.skupin=rev(stevilo.skupin.v),
diff = rev(diff.v))
useOld = FALSE # ne uporabljal starega rezultata
if(useOld&&file.exists("simulacija.RDS")){
res = readRDS("simulacija.RDS")
}else{
# potrebne knjiznice
library(foreach)
library(doParallel)
library(doRNG)
# parallel computing
nc = detectCores()-1
cl = makeCluster(nc, outfile="logSimulacija") # shranjujemo konzolo
registerDoParallel(cl)
set.seed(2024)
timePar = system.time({ # za time
res = foreach(i = 1:nrow(settings), .combine=rbind) %dorng% {
# izberemo faktorje
stevilo.spremenljivk = settings$stevilo.spremenljivk[i]
stevilo.skupin = settings$stevilo.skupin[i]
velikost.skupin = settings$velikost.skupin[i]
diff = settings$diff[i]
# za rezultate
res = data.frame(settings[rep(i,m*length(kMeansRep)),], id=NA, nRep=NA, ari=NA, wss=NA, pwss=NA)
# pazi da bodo pravi podatki v pravi vrstici
ind = 0
for(j in 1:m){
# generiramo podatke
data = generiranje.podatkov(stevilo.spremenljivk= stevilo.spremenljivk,
velikost.skupin = velikost.skupin,
stevilo.skupin = stevilo.skupin,
diff = diff)
# transformacija v data.frame
data = as.data.frame(data)
# najprej sm nardila sam za eno metodo
for(nRep in stevilo.zacetnih.skupin){
# metoda kmeans
kmeans.res = kmeans(dat[,1:stevilo.spremenljivk], centers=stevilo.skupin, nstart=nRep)
# zapis v pravo vrstico
ind = ind+1
res$id[ind] = i*m*10 + j
res$nRep[ind] = nRep
# mere
res$ari[ind] = blockmodeling::crand(dat$skupina, kmeans.res$cluster) #prava vrednost in vrednost iz rezultatov
res$wss[ind] = kmeans.res$tot.withinss
res$pwss[ind] = kmeans.res$tot.withinss/kmeans.res$totss
}
}
cat("Setting ",i,"/",nrow(settings), " done.\t", format(Sys.time()) ,"\n", sep="")
return(res)
}
})
attr(res, "time") = timePar
cat("Time needed in min:", timePar[3]/60, "\n")
saveRDS(res, "simulacija.RDS")
stopCluster(cl)
}
################################## simulacija ##################################
m = 5 # st. ponovitev
stevilo.skupin.v = c(4, 8, 10)
velikost.skupin.v = c(20, 100, 200)
stevilo.spremenljivk.v = c(8, 16, 32)
diff.v = c(0.5, 1, 2, 10)
stevilo.zacetnih.skupin = c(1, 4, 10, 100)
settings = expand.grid(stevilo.spremenljivk = rev(stevilo.spremenljivk.v),
velikost.skupin = rev(velikost.skupin.v),
stevilo.skupin=rev(stevilo.skupin.v),
diff = rev(diff.v))
useOld = FALSE # ne uporabljal starega rezultata
if(useOld&&file.exists("simulacija.RDS")){
res = readRDS("simulacija.RDS")
}else{
# potrebne knjiznice
library(foreach)
library(doParallel)
library(doRNG)
# parallel computing
nc = detectCores()-1
cl = makeCluster(nc, outfile="logSimulacija") # shranjujemo konzolo
registerDoParallel(cl)
set.seed(2024)
timePar = system.time({ # za time
res = foreach(i = 1:nrow(settings), .combine=rbind) %dorng% {
# izberemo faktorje
stevilo.spremenljivk = settings$stevilo.spremenljivk[i]
stevilo.skupin = settings$stevilo.skupin[i]
velikost.skupin = settings$velikost.skupin[i]
diff = settings$diff[i]
# za rezultate
res = data.frame(settings[rep(i,m*length(stevilo.zacetnih.skupin)),], id=NA, nRep=NA, ari=NA, wss=NA, pwss=NA)
# pazi da bodo pravi podatki v pravi vrstici
ind = 0
for(j in 1:m){
# generiramo podatke
data = generiranje.podatkov(stevilo.spremenljivk= stevilo.spremenljivk,
velikost.skupin = velikost.skupin,
stevilo.skupin = stevilo.skupin,
diff = diff)
# transformacija v data.frame
data = as.data.frame(data)
# najprej sm nardila sam za eno metodo
for(nRep in stevilo.zacetnih.skupin){
# metoda kmeans
kmeans.res = kmeans(dat[,1:stevilo.spremenljivk], centers=stevilo.skupin, nstart=nRep)
# zapis v pravo vrstico
ind = ind+1
res$id[ind] = i*m*10 + j
res$nRep[ind] = nRep
# mere
res$ari[ind] = blockmodeling::crand(dat$skupina, kmeans.res$cluster) #prava vrednost in vrednost iz rezultatov
res$wss[ind] = kmeans.res$tot.withinss
res$pwss[ind] = kmeans.res$tot.withinss/kmeans.res$totss
}
}
cat("Setting ",i,"/",nrow(settings), " done.\t", format(Sys.time()) ,"\n", sep="")
return(res)
}
})
attr(res, "time") = timePar
cat("Time needed in min:", timePar[3]/60, "\n")
saveRDS(res, "simulacija.RDS")
stopCluster(cl)
}
################################## simulacija ##################################
m = 5 # st. ponovitev
stevilo.skupin.v = c(4, 8, 10)
velikost.skupin.v = c(20, 100, 200)
stevilo.spremenljivk.v = c(8, 16, 32)
diff.v = c(0.5, 1, 2, 10)
stevilo.zacetnih.skupin = c(1, 4, 10, 100)
settings = expand.grid(stevilo.spremenljivk = rev(stevilo.spremenljivk.v),
velikost.skupin = rev(velikost.skupin.v),
stevilo.skupin=rev(stevilo.skupin.v),
diff = rev(diff.v))
useOld = FALSE # ne uporabljal starega rezultata
if(useOld&&file.exists("simulacija.RDS")){
res = readRDS("simulacija.RDS")
}else{
# potrebne knjiznice
library(foreach)
library(doParallel)
library(doRNG)
# parallel computing
nc = detectCores()-1
cl = makeCluster(nc, outfile="logSimulacija") # shranjujemo konzolo
registerDoParallel(cl)
set.seed(2024)
timePar = system.time({ # za time
res = foreach(i = 1:nrow(settings), .combine=rbind) %dorng% {
# izberemo faktorje
stevilo.spremenljivk = settings$stevilo.spremenljivk[i]
stevilo.skupin = settings$stevilo.skupin[i]
velikost.skupin = settings$velikost.skupin[i]
diff = settings$diff[i]
# za rezultate
res = data.frame(settings[rep(i,m*length(stevilo.zacetnih.skupin)),], id=NA, nRep=NA, ari=NA, wss=NA, pwss=NA)
# pazi da bodo pravi podatki v pravi vrstici
ind = 0
for(j in 1:m){
# generiramo podatke
data = generiranje.podatkov(stevilo.spremenljivk= stevilo.spremenljivk,
velikost.skupin = velikost.skupin,
stevilo.skupin = stevilo.skupin,
diff = diff)
# transformacija v data.frame
data = as.data.frame(data)
# najprej sm nardila sam za eno metodo
for(nRep in stevilo.zacetnih.skupin){
# metoda kmeans
kmeans.res = kmeans(data[,1:stevilo.spremenljivk], centers=stevilo.skupin, nstart=nRep)
# zapis v pravo vrstico
ind = ind+1
res$id[ind] = i*m*10 + j
res$nRep[ind] = nRep
# mere
res$ari[ind] = blockmodeling::crand(data$skupina, kmeans.res$cluster) #prava vrednost in vrednost iz rezultatov
res$wss[ind] = kmeans.res$tot.withinss
res$pwss[ind] = kmeans.res$tot.withinss/kmeans.res$totss
}
}
cat("Setting ",i,"/",nrow(settings), " done.\t", format(Sys.time()) ,"\n", sep="")
return(res)
}
})
attr(res, "time") = timePar
cat("Time needed in min:", timePar[3]/60, "\n")
saveRDS(res, "simulacija.RDS")
stopCluster(cl)
}
################################## simulacija ##################################
m = 5 # st. ponovitev
stevilo.skupin.v = c(4, 8, 10)
velikost.skupin.v = c(20, 100, 200)
stevilo.spremenljivk.v = c(10, 20, 30)
diff.v = c(0.5, 1, 2, 10)
stevilo.zacetnih.skupin = c(1, 4, 10, 100)
settings = expand.grid(stevilo.spremenljivk = rev(stevilo.spremenljivk.v),
velikost.skupin = rev(velikost.skupin.v),
stevilo.skupin=rev(stevilo.skupin.v),
diff = rev(diff.v))
useOld = FALSE # ne uporabljal starega rezultata
if(useOld&&file.exists("simulacija.RDS")){
res = readRDS("simulacija.RDS")
}else{
# potrebne knjiznice
library(foreach)
library(doParallel)
library(doRNG)
# parallel computing
nc = detectCores()-1
cl = makeCluster(nc, outfile="logSimulacija") # shranjujemo konzolo
registerDoParallel(cl)
set.seed(2024)
timePar = system.time({ # za time
res = foreach(i = 1:nrow(settings), .combine=rbind) %dorng% {
# izberemo faktorje
stevilo.spremenljivk = settings$stevilo.spremenljivk[i]
stevilo.skupin = settings$stevilo.skupin[i]
velikost.skupin = settings$velikost.skupin[i]
diff = settings$diff[i]
# za rezultate
res = data.frame(settings[rep(i,m*length(stevilo.zacetnih.skupin)),], id=NA, nRep=NA, ari=NA, wss=NA, pwss=NA)
# pazi da bodo pravi podatki v pravi vrstici
ind = 0
for(j in 1:m){
# generiramo podatke
data = generiranje.podatkov(stevilo.spremenljivk= stevilo.spremenljivk,
velikost.skupin = velikost.skupin,
stevilo.skupin = stevilo.skupin,
diff = diff)
# transformacija v data.frame
data = as.data.frame(data)
# najprej sm nardila sam za eno metodo
for(nRep in stevilo.zacetnih.skupin){
# metoda kmeans
kmeans.res = kmeans(data[,1:stevilo.spremenljivk], centers=stevilo.skupin, nstart=nRep)
# zapis v pravo vrstico
ind = ind+1
res$id[ind] = i*m*10 + j
res$nRep[ind] = nRep
# mere
res$ari[ind] = blockmodeling::crand(data$skupina, kmeans.res$cluster) #prava vrednost in vrednost iz rezultatov
res$wss[ind] = kmeans.res$tot.withinss
res$pwss[ind] = kmeans.res$tot.withinss/kmeans.res$totss
}
}
cat("Setting ",i,"/",nrow(settings), " done.\t", format(Sys.time()) ,"\n", sep="")
return(res)
}
})
attr(res, "time") = timePar
cat("Time needed in min:", timePar[3]/60, "\n")
saveRDS(res, "simulacija.RDS")
stopCluster(cl)
}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center", fig.pos = "H", message = FALSE, warning = FALSE, results = F, fig.height =3, fig.width = 6.5)
# potrebne knjižnice
library(ggplot2)
library(car)
library(tidyr)
library(ADGofTest)
# seme
set.seed(2024)
generiranje.podatkov = function(stevilo.spremenljivk, velikost.skupin, stevilo.skupin, diff){
# generiranje povprečij
M = diag(stevilo.skupin)*diff
# neinformativne spremenljivke - same 0
M = cbind(M, matrix(0, nrow=stevilo.skupin, ncol=stevilo.spremenljivk-stevilo.skupin))
S = diag(stevilo.spremenljivk)
X = NULL
# generamo podatke za vsako skupino posebaj
for(i in 1:stevilo.skupin){
iX = MASS::mvrnorm(n=velikost.skupin, mu = M[i,], Sigma = S)
X = rbind(X,iX)
}
# dodamo se skupino
X = cbind(X, skupina=rep(1:stevilo.skupin,each=velikost.skupin)) # clu = skupina
return(X)
}
data.primer1 = generiranje.podatkov(stevilo.spremenljivk = 12, velikost.skupin = 100, stevilo.skupin = 4, diff = 2)
data.primer1
setwd("~/Documents/viri_podatkov/racunsko_zahtevne_metode/02_naloga")
set.seed(2024)
########################## generiranje podatkov #############################
# funkcija za generiranje podatkov
generiranje.podatkov = function(stevilo.spremenljivk, velikost.skupin, stevilo.skupin, diff){
# generiranje povprečij
M = diag(stevilo.skupin)*diff
# neinformativne spremenljivke - same 0
M = cbind(M, matrix(0, nrow=stevilo.skupin, ncol=stevilo.spremenljivk-stevilo.skupin))
S = diag(stevilo.spremenljivk)
X = NULL
# generamo podatke za vsako skupino posebaj
for(i in 1:stevilo.skupin){
iX = MASS::mvrnorm(n=velikost.skupin, mu = M[i,], Sigma = S)
X = rbind(X,iX)
}
# dodamo se skupino
X = cbind(X, skupina=rep(1:stevilo.skupin,each=velikost.skupin)) # clu = skupina
return(X)
}
################################## simulacija ##################################
m = 100 # st. ponovitev
stevilo.skupin.v = c(4, 8, 10)
velikost.skupin.v = c(20, 100, 200)
stevilo.spremenljivk.v = c(12, 24, 36)
diff.v = c(1, 2, 4, 10)
settings = expand.grid(i=1:m, stevilo.spremenljivk = rev(stevilo.spremenljivk.v),
velikost.skupin = rev(velikost.skupin.v),
stevilo.skupin=rev(stevilo.skupin.v),
diff = rev(diff.v))
useOld = FALSE # ne uporabljal starega rezultata
if(useOld&&file.exists("simulacija.RDS")){
res = readRDS("simulacija.RDS")
}else{
# potrebne knjiznice
# neke tezave z mclust zato je tkole zdej
# potrebne.knjiznice <- c("foreach", "doParallel", "doRNG", "mclust", "blockmodeling")
# nove.knjiznice <- potrebne.knjiznice[!(potrebne.knjiznice %in% installed.packages()[,"Package"])]
# if (length(nove.knjiznice)) install.packages(nove.knjiznice)
# lapply(potrebne.knjiznice, library, character.only = TRUE)
library(foreach)
library(doParallel)
library(doRNG)
library(mclust)
# parallel computing
nc = detectCores()-1
cl = makeCluster(nc, outfile="logSimulacija") # shranjujemo konzolo
# nalozimo ustrezne pakete za vsak cluster worker
clusterEvalQ(cl, {
library(mclust)})
registerDoParallel(cl)
set.seed(2024)
res = cbind(settings,
ari.kmeans=NA, wss.kmeans=NA, pwss.kmeans=NA,
ari.mclust=NA, wss.mclust=NA, pwss.mclust=NA)
for(row in 1:nrow(settings)){
# row = 1
# izberemo faktorje
stevilo.spremenljivk = settings$stevilo.spremenljivk[row]
stevilo.skupin = settings$stevilo.skupin[row]
velikost.skupin = settings$velikost.skupin[row]
diff = settings$diff[row]
# generiramo podatke
data = generiranje.podatkov(stevilo.spremenljivk= stevilo.spremenljivk,
velikost.skupin = velikost.skupin,
stevilo.skupin = stevilo.skupin,
diff = diff)
# transformacija v data.frame
data = as.data.frame(data)
# skaliramo podatke za metodo razvrscanje na polagi modelov
data.scale = scale(data[,1:stevilo.spremenljivk])
# metoda kmeans
kmeans.res = kmeans(data[,1:stevilo.spremenljivk], centers=stevilo.skupin, nstart = 100) #, nstart=nRep)
res$ari.kmeans[row] = blockmodeling::crand(data$skupina, kmeans.res$cluster) #ari
res$wss.kmeans[row] = kmeans.res$tot.withinss #wss
res$pwss.kmeans[row] = kmeans.res$tot.withinss/kmeans.res$totss #pwss
# razvrscanje na polagi modelov
suppressMessages({ # v konzoli se ne izpisuje fitting
model = capture.output({
mclust.res = mclust::Mclust(data.scale, G = stevilo.skupin)
})
})
# ari
res$ari.mclust[row] = blockmodeling::crand(data$skupina, mclust.res$classification)
# wss
wss.mclust = sum(sapply(1:stevilo.skupin, function(k) {
sum(rowSums((as.matrix(data.scale[mclust.res$classification == k, ]) -
colMeans(as.matrix(data.scale[mclust.res$classification == k, ])))^2))
}))
res$wss.mclust[row] = wss.mclust
# pwss
res$pwss.mclust[row] = wss.mclust / sum((data.scale - colMeans(data.scale))^2)
# kje se nahaja zanka
if(row%%10==0) cat("Iteration ", row, "/", nrow(settings), "complete! \n")
}
saveRDS(object = res, file="simulacija.RDS")
stopCluster(cl)
}
# Neza28: to mava ze ta randov index sam da mava adjusted...
################################# grafični prikaz ##############################
library(tidyr)
library(dplyr)
resLong = pivot_longer(res, cols =matches("^(ari|wss|pwss)\\."),  values_to = "value",
names_to = c("metric", "method"), names_pattern = "^(ari|wss|pwss)\\.(kmeans|mclust)")
resWide <- resLong %>% pivot_wider(names_from = metric, values_from = value) # da so ari, wss in pwss vsaka svoj column
resAgg = aggregate(cbind(ari, wss, pwss) ~ stevilo.spremenljivk + velikost.skupin + stevilo.skupin + method,
data = resWide, FUN = mean)
# vrednosti dava v factor zaradi risanja
resAggFac = resAgg
resAggFac$stevilo.spremenljivk = as.factor(resAggFac$stevilo.spremenljivk)
resAggFac$velikost.skupin = as.factor(resAggFac$velikost.skupin)
resAggFac$stevilo.skupin = as.factor(resAggFac$stevilo.skupin)
library(ggplot2)
# risemo adjR2
ggplot(resAggFac, aes(y = ari, x = stevilo.spremenljivk, col=method, group=method)) +
geom_point() + geom_line() +
facet_grid(stevilo.skupin ~ velikost.skupin, scales="free")
