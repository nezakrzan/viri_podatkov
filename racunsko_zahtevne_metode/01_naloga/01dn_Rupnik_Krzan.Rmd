---
title: "Domača naloga 1"
author: "Neža Kržan, Tom Rupnik Medjedovič"
output:
  pdf_document:
    fig_caption: true
    number_sections: true
header-includes:
- \usepackage[slovene]{babel}
- \usepackage{float}
- \usepackage[T1]{fontenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center", fig.pos = "H", message = FALSE, warning = FALSE, results = F, fig.height =3, fig.width = 6.5)

# potrebne knjižnice
library(ggplot2)
library(car)
library(tidyr)
library(ADGofTest)

# seme
set.seed(2024)
```


# Navodilo{-}

Estimate the validity of a test for the difference of arithmetic means from three independent samples. Compare method where you assume:

- equal variance (classic ANOVA)
- unequal variances (Welch's ANOVA)
- an option where you assume equal variances if you cannot reject the assumption of equality of variances (at 5% risk) with some test for equality of variances (e.g. Levene's), and unequal variances if you can.

Generate the data so that the variances are equal in some places and different in others.

<!--
Prevod v SLO:
Oceni veljavnost testa za razliko aritmetičnih sredin iz treh neodvisnih vzorcev. Primerjaj naslednje metode:
- predpostavka enakih varianc (klasični ANOVA),
- predpostavka neenakih varianc (Welchov ANOVA),
- možnost, kjer predpostaviš enake variance, če ne moreš zavrniti predpostavke o enakosti varianc (pri 5 % tveganju) s kakšnim testom za enakost varianc (npr. Levenejev test), in neenake variance, če lahko.

Generiraj podatke tako, da bodo variance na nekaterih mestih enake, na drugih pa različne.

Ker mamo validity of a test mormo:
If you are assessing the validity of a test, use (at least) two measures, one relating to the distribution of the p-value or test statistic and one testing the size of the test at the chosen level of risk.
-->

# Generiranje podatkov

```{r generiranje podatkov, fig.cap="Primer gostote porazdelitev skupin(velikost skupin 1000) za različne kombinacije varianc.", return_all = TRUE}
generate_data <- function(n, means, vars) {
  sample1 <- rnorm(n, mean = means, sd = sqrt(vars[1]))
  sample2 <- rnorm(n, mean = means, sd = sqrt(vars[2]))
  sample3 <- rnorm(n, mean = means, sd = sqrt(vars[3]))
  data = data.frame(sample1 = sample1, sample2 = sample2, sample3 = sample3)
  return(data)
}

n = 1000
means = 0
# vars = c("1,1,1", "1,10,1", "1,5,10")

vars = c(1,10,1)
data = generate_data(n, means, vars)
data.long = data.frame(vrednosti = c(data$sample1, data$sample2, data$sample3),
                       vzorec = c(rep("vzorec 1", n), rep("vzorec 2", n), rep("vzorec 3", n)))
g1 = ggplot(data.long, aes(x = vrednosti, color = vzorec)) +
  geom_density(size = 0.5) + 
  labs(title = "var = (1,10,1)",
       x = " ",
       y = "density",
       color = " ") +
  guides(color = guide_legend(nrow = 1, override.aes = list(linetype = 1, shape = 15))) + 
  theme_minimal() 

library(cowplot)
legend <- get_legend(g1)
g1 = g1 + theme(legend.position = "none")

vars = c(1,5,10)
data = generate_data(n, means, vars)
data.long = data.frame(vrednosti = c(data$sample1, data$sample2, data$sample3),
                       vzorec = c(rep("vzorec 1", n), rep("vzorec 2", n), rep("vzorec 3", n)))
g2 = ggplot(data.long, aes(x = vrednosti, color = vzorec)) +
  geom_density(size = 0.5) + 
  labs(title = "var = (1,5,10)",
       x = " ",
       y = " ",
       color = " ") +
  guides(color = guide_legend(override.aes = list(linetype = 1, shape = 15))) + 
  theme_minimal() + 
  theme(legend.position = "none")

vars = c(1,1,1)
data = generate_data(n, means, vars)
data.long = data.frame(vrednosti = c(data$sample1, data$sample2, data$sample3),
                       vzorec = c(rep("vzorec 1", n), rep("vzorec 2", n), rep("vzorec 3", n)))
g3 = ggplot(data.long, aes(x = vrednosti, color = vzorec)) +
  geom_density(size = 0.5) + 
  labs(title = "var = (1,1,1)",
       x = " ",
       y = " ",
       color = " ") +
  guides(color = guide_legend(override.aes = list(linetype = 1, shape = 15))) + 
  theme_minimal()+ 
  theme(legend.position = "none")

library(gridExtra)
combined_plots <- plot_grid(g1, g2, g3, nrow = 1)
plot_grid(combined_plots, legend, ncol = 1, rel_heights = c(1, 0.3))

# ne vem al je bols da je box plot?
# ggplot(data.long, aes(x = vzorec, y = vrednosti, color = vzorec)) +
#  geom_boxplot(size = 0.5) + 
#  labs(title = " ",
#       x = " ",
#       y = "density",
#       color = " ") +
#  guides(color = guide_legend(override.aes = list(linetype = 1, shape = 15))) + 
#  theme_minimal()
```

\newpage

Podatke sva generirala tako, da je porazdelitev znotraj posamezne skupine normalna s povprečjem 0 ($\mu_i = 0$). Variabilnost posamezne skupine sva nekoliko spreminjala, tako da sva lahko preverila veljavnost testa za razliko aritmetičnih sredin v primeru, da je predpostavka enakih varianc izpolnjena oz. kršena. V ta namen sva si izbrala primere treh skupin z naslednjo varianco:

* (1, 10, 1),
* (1, 5, 10),
* (1, 1, 1).

Poleg tega sva spreminjala tudi velikost skupin, izbrala sva si velikosti $n \in \{15, 40, 100, 200, 500\}$, pri čemer imajo vse skupine vedno enako velikost, torej npr. $[15, 15, 15]$. 

Pričakujeva, da bo klasični ANOVA test dobro deloval le v primeru, ko je predpostavka enakih varianc izpolnjena in pričakujeva, da velikost skupin ne bo veliko vplivala na rezultate tega testa. Za druga dva testa(Welch's ANOVA in p-vrednost na podlagi Levene's testa) pa pričakujeva, da dobro delujeta tako v primeru izpolnjene kot tudi kršene predpostavke. Moč testov bo pri enakih variancah verjetno približno enaka za vse 3, s tem ko pri različnih pa bo večja pri drugih dveh testih(Welch's ANOVA in p-vrednost na podlagi Levene's testa). Pričakujeva, da se bo moč večala z večanjem vzorca.

# Simulacije (p-vrednost)

<!-- 
Tom: 
Ker preverjava ustreznost testa je v vseh skupinah enako povprecje 0
jst bi porazdelitev pustil kr skoz normalno,
spreminjava samo variance recimo:
- vse enake (1,1,1)
- ena razlicna (1, 10, 1)
- vse razlicne (1, 5, 10)

pa potem se da mal spreminjava velikost skupin:
- vse enake ([15, 15, 15], [40, 40, 40], [100, 100, 100], [1000, 1000, 1000])
-->

V simulacijah, kjer preverjava enakomerno porazdelitev $p$-vrednosti, sva spreminjala 
varianco v posamezni skupini in velikost posamezne skupine.

Na grafih je prikazana $p$-vrednost Anderson-Darling testa z ničelno hipotezo 
$$H_0: \text{vzorec sledi zvezni enakomerni porazdelitvi}$$
Želeli bi, da je porazdelitev $p$-vrednosti podobna zvezni enakomerni porazdelitvi, torej da enakomerno zavzame vse vrednosti na intervalu [0,1].

```{r simulacije p-vrednost}
st_ponovitev = 6000
velikost = c(15, 40, 60, 100, 200, 500)

settings = expand.grid(i=1:st_ponovitev, n = velikost,
                       var = c("1,10,1", "1,5,10", "1,1,1"))

if(file.exists("p_vrednost.RDS")){
  res<-readRDS("p_vrednost.RDS")
} else {
  res<-cbind(settings, pANOVA=NA, pANOVA_2=NA, pMETHOD3=NA)
  for(row in 1:nrow(settings)){
    velikost = settings$n[row]
    var_skupaj = as.numeric(strsplit(as.character(settings$var[row]),",")[[1]])
    sd1 = sqrt(var_skupaj[1])
    sd2 = sqrt(var_skupaj[2])
    sd3 = sqrt(var_skupaj[3])
    
    x<-c(rnorm(velikost, 0, sd1),
         rnorm(velikost, 0, sd2),
         rnorm(velikost, 0, sd3))
    gr<-factor(rep(1:3, times=c(velikost,velikost,velikost)))
    
    res$pANOVA[row] = summary(aov(x~gr))[[1]][["Pr(>F)"]][1]
    res$pANOVA_2[row] = oneway.test(x~gr, var.equal = FALSE)$p.value
    
    p_test_enak_V = leveneTest(x~gr)$`Pr(>F)`[1]
    if(p_test_enak_V > 0.05){
      res$pMETHOD3[row] = summary(aov(x~gr))[[1]][["Pr(>F)"]][1]
    } else {
      res$pMETHOD3[row] = oneway.test(x~gr, var.equal = FALSE)$p.value
    }
  }
  saveRDS(object = res, file="p_vrednost.RDS")
}
```

```{r risanje p-vrednost, fig.cap="Prikaz p-vrednosti Anderson-Darling testa."}
# dava v format long
resLong = pivot_longer(res, cols=matches("^p[AM]"), values_to = "pVal",
                       names_to = "method", names_prefix = "p")
resLong$method[resLong$method == "ANOVA"] = "classic ANOVA"
resLong$method[resLong$method == "ANOVA_2"] = "Welch's ANOVA"
resLong$method[resLong$method == "METHOD3"] = "Levene's test"

levels(resLong$var) = c("var = (1,10,1)", "var = (1,5,10)", "var = (1,1,1)")

# testirava za enakomerno porazdelitev z Anderson-Darling testom
valAnal = aggregate(pVal~ n + var + method , data = resLong,
                    function(x)ad.test(x, distr.fun = punif)$p.value)
valAnal$method[valAnal$method == "ANOVA"] = "classic ANOVA"
valAnal$method[valAnal$method == "ANOVA_2"] = "Welch's ANOVA"
valAnal$method[valAnal$method == "METHOD3"] = "Levene's test"

valAnal$n<-as.factor(valAnal$n)
ggplot(valAnal, aes(y=pVal, col=method, group=method, x=n))+
  geom_point()+geom_line()+
  geom_hline(yintercept = 0.05)+
  facet_wrap(vars(var))+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  ylab("p-vrednost") + 
  xlab("velikost skupin(n)") + 
  labs(title = " ",
       color = " ") + 
  theme_minimal() +
  theme(legend.position = "bottom")
```

Kot sva že na začetku predvidela, klasična ANOVA(classic ANOVA) v primeru različnih varianc ni veljavna, saj ima $p$-vrednost enako oz. blizu 0 za vse velikosti vzorca. To pomeni, da zavrnemo ničelno hipotezo. \
V primeru, ko je varianca v vseh treh skupinah enaka, so vse $p$-vrednosti nad mejo $0.05$, torej ne moremo zavrniti ničelne hipoteze.

# Velikost testa

Na podlagi zgornjega grafa pričakujeva, da velikost testa v primeru klasičnega ANOVA testa in različnih varianc ne bo enaka oz. blizu vrednosti $0.05$. Zaradi kršenja predpostavk bomo prevečkrat oz. premalokrat zavračali ničelno hipotezo, ko ta drži.

```{r risanje velikosti testa, fig.cap="Prikaz velikosti testa pri različnih parametrih."}
valAnal = aggregate(pVal~ n + var + method , data = resLong,
                    function(x)mean(x<0.05))
valAnal$method[valAnal$method == "ANOVA"] = "classic ANOVA"
valAnal$method[valAnal$method == "ANOVA_2"] = "Welch's ANOVA"
valAnal$method[valAnal$method == "METHOD3"] = "Levene's test"

valAnal$n<-as.factor(valAnal$n)
ggplot(valAnal, aes(y=pVal, col=method, group=method, x=n))+
  geom_point()+geom_line()+#geom_smooth(se=F)+
  geom_hline(yintercept = 0.05)+
  facet_wrap(vars(var)) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  ylab("delez zavrnitve") +
  xlab("velikost skupin(n)") + 
  labs(title = " ",
       color = " ") + 
  theme_minimal() +
  theme(legend.position = "bottom")
```

Res smo potrdili zgornje predvidevanje. V primeru različnih varianc klasični ANOVA test prevečkrat zavrne ničelno hipotezo. Ko pa je varianca v vseh treh skupinah enaka $1$, so vrednosti dokaj podobne. 

# Moč testa

Glede na moč testa lahko primerjamo vse tri teste le v primeru enakih varianc. V preostalih primerih klasični ANOVA test ni veljaven, zato bomo primerjali le preostala dva. Najprej sva primerjala med seboj teste v primeru enakih varianc, nato pa še v primeru različnih.

## Enake variance {-}

<!--Neza: kle mi ta povprecje ni cist jasn, kaj tocno zeliva s tem?-->

```{r simulacije moc testa enake varinace}
st_ponovitev = 2000
velikost = c(15, 40, 60, 100, 200, 500)
povp = c("0,0.5,0", "0,-0.5,0.5") # Neza: kaj je tole povp?

settings = expand.grid(i=1:st_ponovitev, n = velikost, povp = povp,
                       var = "1,1,1")

if(file.exists("moc_enake.RDS")){
  res_p<-readRDS("moc_enake.RDS")
} else {
  res_p<-cbind(settings, pANOVA=NA, pANOVA_2=NA, pMETHOD3=NA)
  for(row in 1:nrow(settings)){
    velikost = settings$n[row]
    var_skupaj = as.numeric(strsplit(as.character(settings$var[row]),",")[[1]])
    sd1 = sqrt(var_skupaj[1])
    sd2 = sqrt(var_skupaj[2])
    sd3 = sqrt(var_skupaj[3])
    povp_skupaj = as.numeric(strsplit(as.character(settings$povp[row]),",")[[1]])
    povp1 = povp_skupaj[1]
    povp2 = povp_skupaj[2]
    povp3 = povp_skupaj[3]
    
    x<-c(rnorm(velikost, povp1, sd1),
         rnorm(velikost, povp2, sd2),
         rnorm(velikost, povp3, sd3))
    gr<-factor(rep(1:3, times=c(velikost,velikost,velikost)))
    
    res_p$pANOVA[row] = summary(aov(x~gr))[[1]][["Pr(>F)"]][1]
    res_p$pANOVA_2[row] = oneway.test(x~gr, var.equal = FALSE)$p.value
    
    p_test_enak_V = leveneTest(x~gr)$`Pr(>F)`[1]
    if(p_test_enak_V > 0.05){
      res_p$pMETHOD3[row] = summary(aov(x~gr))[[1]][["Pr(>F)"]][1]
    } else {
      res_p$pMETHOD3[row] = oneway.test(x~gr, var.equal = FALSE)$p.value
    }
  }
  saveRDS(object = res_p, file="moc_enake.RDS")
}

```

```{r risanje moci enake var, fig.cap="Prikaz moči testa v primeru enakih varianc.", fig.height=2.5}
# dava v format long
resLong_P = pivot_longer(res_p, cols=matches("^p[AM]"), values_to = "power",
                       names_to = "method", names_prefix = "p")
levels(resLong_P$povp) = c("povp = (0,0.5,0)", "povp = (0,-0.5,0.5)")
levels(resLong_P$var) = c("var = (1,1,1)")

# testirava za enakomerno porazdelitev z Anderson-Darling testom
valAnal_P = aggregate(power ~ n + method + povp, data = resLong_P,
                    function(x)mean(x<0.05))
valAnal_P$method[valAnal_P$method == "ANOVA"] = "classic ANOVA"
valAnal_P$method[valAnal_P$method == "ANOVA_2"] = "Welch's ANOVA"
valAnal_P$method[valAnal_P$method == "METHOD3"] = "Levene's test"

valAnal_P$n<-as.factor(valAnal_P$n)
ggplot(valAnal_P, aes(y=power, col=method, group=method, x=n))+
  geom_point()+geom_line()+
  geom_hline(yintercept = 0.05)+
  facet_wrap(vars(povp))+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  ylab("moc") +
  xlab("velikost skupin(n)") + 
  labs(title = " ",
       color = " ") + 
  theme_minimal()  
```

Na podlagi zgornjega grafa ne moremo govoriti o velikih razlikah med testi. Vsi testi imajo zelo podobno moč testa. Pričakovano z naraščanjem velikosti skupin narašča tudi moč testa. Opazimo lahko tudi, da je v primeru različnega povprečja le v eni skupini manjša moč kot v primeru različnega povprečja v vseh skupinah.

## Različne variance {-}

```{r simulacije moc testa razlicne varinace}
st_ponovitev = 2000
velikost = c(15, 40, 60, 100, 200, 500)
povp = c("0,1,0", "0,-1,1")

settings = expand.grid(i=1:st_ponovitev, n = velikost, povp = povp,
                       var = c("1,10,1", "1,5,10"))

if(file.exists("moc_razlicne.RDS")){
  res_p<-readRDS("moc_razlicne.RDS")
} else {
  res_p<-cbind(settings, pANOVA_2=NA, pMETHOD3=NA)
  for(row in 1:nrow(settings)){
    velikost = settings$n[row]
    var_skupaj = as.numeric(strsplit(as.character(settings$var[row]),",")[[1]])
    sd1 = sqrt(var_skupaj[1])
    sd2 = sqrt(var_skupaj[2])
    sd3 = sqrt(var_skupaj[3])
    povp_skupaj = as.numeric(strsplit(as.character(settings$povp[row]),",")[[1]])
    povp1 = povp_skupaj[1]
    povp2 = povp_skupaj[2]
    povp3 = povp_skupaj[3]
    
    x<-c(rnorm(velikost, povp1, sd1),
         rnorm(velikost, povp2, sd2),
         rnorm(velikost, povp3, sd3))
    gr<-factor(rep(1:3, times=c(velikost,velikost,velikost)))
    
    # res_p$pANOVA[row] = summary(aov(x~gr))[[1]][["Pr(>F)"]][1]
    res_p$pANOVA_2[row] = oneway.test(x~gr, var.equal = FALSE)$p.value
    
    p_test_enak_V = leveneTest(x~gr)$`Pr(>F)`[1]
    if(p_test_enak_V > 0.05){
      res_p$pMETHOD3[row] = summary(aov(x~gr))[[1]][["Pr(>F)"]][1]
    } else {
      res_p$pMETHOD3[row] = oneway.test(x~gr, var.equal = FALSE)$p.value
    }
  }
  saveRDS(object = res_p, file="moc_razlicne.RDS")
}

```


```{r risanje moci razlicne var, fig.cap="Prikaz moči testa v primeru različnih varianc(vrstice predstavljajo varinaco skupin, stolpci pa povprečje posamezne skupine)."}
# dava v format long
resLong_P = pivot_longer(res_p, cols=matches("^p[AM]"), values_to = "power",
                       names_to = "method", names_prefix = "p")
levels(resLong_P$povp) = c("povp = (0,1,0)", "povp = (0,-1,1)")
levels(resLong_P$var) = c("var = (1,10,1)", "var = (1,5,10)")

# testirava za enakomerno porazdelitev z Anderson-Darling testom
valAnal_P = aggregate(power ~ n + var + method + povp, data = resLong_P,
                    function(x)mean(x<0.05))
valAnal_P$method[valAnal_P$method == "ANOVA"] = "classic ANOVA"
valAnal_P$method[valAnal_P$method == "ANOVA_2"] = "Welch's ANOVA"
valAnal_P$method[valAnal_P$method == "METHOD3"] = "Levene's test"

valAnal_P$n<-as.factor(valAnal_P$n)
ggplot(valAnal_P, aes(y=power, col=method, group=method, x=n))+
  geom_point()+geom_line()+
  geom_hline(yintercept = 0.05)+
  facet_grid(var~povp)+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  ylab("moč") +
  xlab("velikost skupin(n)") + 
  labs(title = " ",
       color = " ") + 
  theme_minimal()  
```

Ponovno imata metodi zelo podobno moč testa. Opazimo, da se moč testa spreminja z velikostjo skupine in kombinacijo variabilnosti skupine in razlike povprečja. V primeru, da je varianca skupine velika in povprečje malo odstopa od preostalih dveh, je moč testa dokaj majhna. Torej manj, kot se porazdelitve skupin med seboj prekrivajo, večja je moč testa.

