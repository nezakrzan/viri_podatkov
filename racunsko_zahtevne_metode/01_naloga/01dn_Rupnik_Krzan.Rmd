---
title: "Domača naloga 1"
author: "Neža Kržan, Tom Rupnik Medjedovič"
output:
  pdf_document:
    fig_caption: true
    number_sections: true
header-includes:
- \usepackage[slovene]{babel}
- \usepackage{float}
- \usepackage[T1]{fontenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center", fig.pos = "H", message = FALSE, warning = FALSE, results = F, fig.height = 4, fig.width = 5)

# potrebne knjižnice
library(ggplot2)
library(car)
library(tidyr)
library(ADGofTest)

# seme
set.seed(2024)
```


# Navodilo{-}

Estimate the validity of a test for the difference of arithmetic means from three independent samples. Compare method where you assume:

- equal variance (classic ANOVA)
- unequal variances (Welch's ANOVA)
- an option where you assume equal variances if you cannot reject the assumption of equality of variances (at 5% risk) with some test for equality of variances (e.g. Levene's), and unequal variances if you can.

Generate the data so that the variances are equal in some places and different in others.

<!--
Prevod v SLO:
Oceni veljavnost testa za razliko aritmetičnih sredin iz treh neodvisnih vzorcev. Primerjaj naslednje metode:
- predpostavka enakih varianc (klasični ANOVA),
- predpostavka neenakih varianc (Welchov ANOVA),
- možnost, kjer predpostaviš enake variance, če ne moreš zavrniti predpostavke o enakosti varianc (pri 5 % tveganju) s kakšnim testom za enakost varianc (npr. Levenejev test), in neenake variance, če lahko.

Generiraj podatke tako, da bodo variance na nekaterih mestih enake, na drugih pa različne.

Ker mamo validity of a test mormo:
If you are assessing the validity of a test, use (at least) two measures, one relating to the distribution of the p-value or test statistic and one testing the size of the test at the chosen level of risk.
-->

# Generiranje podatkov

```{r generiranje podatkov, fig.cap="Primer gostote porazdelitev vzorcev za različne kombinacije varianc.", return_all = TRUE}
generate_data <- function(n, means, vars) {
  sample1 <- rnorm(n, mean = means, sd = sqrt(vars[1]))
  sample2 <- rnorm(n, mean = means, sd = sqrt(vars[2]))
  sample3 <- rnorm(n, mean = means, sd = sqrt(vars[3]))
  data = data.frame(sample1 = sample1, sample2 = sample2, sample3 = sample3)
  return(data)
}

n = 1000
means = 0
# vars = c("1,1,1", "1,10,1", "1,5,10")

vars = c(1,10,1)
data = generate_data(n, means, vars)
data.long = data.frame(vrednosti = c(data$sample1, data$sample2, data$sample3),
                       vzorec = c(rep("vzorec 1", n), rep("vzorec 2", n), rep("vzorec 3", n)))
g1 = ggplot(data.long, aes(x = vrednosti, color = vzorec)) +
  geom_density(size = 0.5) + 
  labs(title = "var = (1,10,1)",
       x = " ",
       y = "density",
       color = " ") +
  guides(color = guide_legend(nrow = 1, override.aes = list(linetype = 1, shape = 15))) + 
  theme_minimal() 

library(cowplot)
legend <- get_legend(g1)
g1 = g1 + theme(legend.position = "none")

vars = c(1,5,10)
data = generate_data(n, means, vars)
data.long = data.frame(vrednosti = c(data$sample1, data$sample2, data$sample3),
                       vzorec = c(rep("vzorec 1", n), rep("vzorec 2", n), rep("vzorec 3", n)))
g2 = ggplot(data.long, aes(x = vrednosti, color = vzorec)) +
  geom_density(size = 0.5) + 
  labs(title = "var = (1,5,10)",
       x = " ",
       y = " ",
       color = " ") +
  guides(color = guide_legend(override.aes = list(linetype = 1, shape = 15))) + 
  theme_minimal() + 
  theme(legend.position = "none")

vars = c(1,1,1)
data = generate_data(n, means, vars)
data.long = data.frame(vrednosti = c(data$sample1, data$sample2, data$sample3),
                       vzorec = c(rep("vzorec 1", n), rep("vzorec 2", n), rep("vzorec 3", n)))
g3 = ggplot(data.long, aes(x = vrednosti, color = vzorec)) +
  geom_density(size = 0.5) + 
  labs(title = "var = (1,1,1)",
       x = " ",
       y = " ",
       color = " ") +
  guides(color = guide_legend(override.aes = list(linetype = 1, shape = 15))) + 
  theme_minimal()+ 
  theme(legend.position = "none")

library(gridExtra)
combined_plots <- plot_grid(g1, g2, g3, nrow = 1)
plot_grid(combined_plots, legend, ncol = 1, rel_heights = c(1, 0.3))

# ne vem al je bols da je box plot?
# ggplot(data.long, aes(x = vzorec, y = vrednosti, color = vzorec)) +
#  geom_boxplot(size = 0.5) + 
#  labs(title = " ",
#       x = " ",
#       y = "density",
#       color = " ") +
#  guides(color = guide_legend(override.aes = list(linetype = 1, shape = 15))) + 
#  theme_minimal()
```

\newpage

Podatke sva generirala tako, da je porazdelitev znotraj posamezne porazdelitve normalna s povprečjem 0 ($\mu_i = 0$). Variabilnost posamezne skupine sva nekoliko spreminjala, tako da sva lahko preverila veljavnost testa za razliko aritmetičnih sredin v primeru, da je predpostavka enakih varianc izpolnjena oz. kršena. V ta namen sva si izbrala primere treh skupin z naslednjo varianco:

* (1, 10, 1)
* (1, 5, 10)
* (1,1,1)

Pričakujeva, da bo klasični ANOVA test dobro deloval le v primeru, ko je predpostavka enakih varianc izpolnjena. Preostala dva testa pa pričakujeva, da dobro delujeta tako v primeru izpolnjene kot tudi kršene predpostavke.

# Simulacije (p-vrednost)

<!-- 
Tom: 
Ker preverjava ustreznost testa je v vseh skupinah enako povprecje 0
jst bi porazdelitev pustil kr skoz normalno,
spreminjava samo variance recimo:
- vse enake (1,1,1)
- ena razlicna (1, 10, 1)
- vse razlicne (1, 5, 10)

pa potem se da mal spreminjava velikost skupin:
- vse enake ([15, 15, 15], [40, 40, 40], [100, 100, 100], [1000, 1000, 1000])
-->

V simulacijah, kjer preverjava enakomerno porazdelitev $p$-vrednosti, sva spreminjala 
varianco v posamezni skupini in velikost posamezne skupine. Varianca, ki sva si izbrala, zavzame vrednosti:

* (1, 10, 1)
* (1, 5, 10)
* (1,1,1)

Za velikost posamezne skupine (vse tri skupine imajo enako vrednost) pa sva si izbrala \ 
$n \in \{15, 40, 100, 200, 500\}$.

Na grafih je prikazana $p$-vrednost Anderson-Darling testa z ničelno hipotezo 
$$H_0: \text{vzorec sledi zvezni enakomerni porazdelitvi}$$
Želeli bi, da je porazdelitev $p$-vrednosti podobna zvezni enakomerni porazdelitvi, torej da enakomerno zavzame vse vrednosti na intervalu [0,1].

```{r simulacije p-vrednost}
st_ponovitev = 6000
velikost = c(15, 40, 60, 100, 200, 500)

settings = expand.grid(i=1:st_ponovitev, n = velikost,
                       var = c("1,10,1", "1,5,10", "1,1,1"))

if(file.exists("p_vrednost.RDS")){
  res<-readRDS("p_vrednost.RDS")
} else {
  res<-cbind(settings, pANOVA=NA, pANOVA_2=NA, pMETHOD3=NA)
  for(row in 1:nrow(settings)){
    velikost = settings$n[row]
    var_skupaj = as.numeric(strsplit(as.character(settings$var[row]),",")[[1]])
    sd1 = sqrt(var_skupaj[1])
    sd2 = sqrt(var_skupaj[2])
    sd3 = sqrt(var_skupaj[3])
    
    x<-c(rnorm(velikost, 0, sd1),
         rnorm(velikost, 0, sd2),
         rnorm(velikost, 0, sd3))
    gr<-factor(rep(1:3, times=c(velikost,velikost,velikost)))
    
    res$pANOVA[row] = summary(aov(x~gr))[[1]][["Pr(>F)"]][1]
    res$pANOVA_2[row] = oneway.test(x~gr, var.equal = FALSE)$p.value
    
    p_test_enak_V = leveneTest(x~gr)$`Pr(>F)`[1]
    if(p_test_enak_V > 0.05){
      res$pMETHOD3[row] = summary(aov(x~gr))[[1]][["Pr(>F)"]][1]
    } else {
      res$pMETHOD3[row] = oneway.test(x~gr, var.equal = FALSE)$p.value
    }
  }
  saveRDS(object = res, file="p_vrednost.RDS")
}

```


```{r risanje p-vrednost}
# dava v format long
resLong = pivot_longer(res, cols=matches("^p[AM]"), values_to = "pVal",
                       names_to = "method", names_prefix = "p")

# testirava za enakomerno porazdelitev z Anderson-Darling testom
valAnal = aggregate(pVal~ n + var + method , data = resLong,
                    function(x)ad.test(x, distr.fun = punif)$p.value)

valAnal$n<-as.factor(valAnal$n)
ggplot(valAnal, aes(y=pVal, col=method, group=method, x=n))+
  geom_point()+geom_line()+
  geom_hline(yintercept = 0.05)+
  facet_wrap(vars(var))+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

Kot sva že na začetku predvidela, klasična ANOVA v primeru različnih varianc ni veljavna, saj ima $p$-vrednost enako oz. blizu 0. To pomeni, da zavrnemo ničelno hipotezo. \
V primeru, ko so variance v vseh treh skupinah enake, so vse $p$-vrednosti nad mejo $0.05$, torej ne moremo zavrniti ničelne hipoteze.

# Velikost testa

Na podlagi zgornjega grafa pričakujeva, da velikost testa v primeru klasičnega ANOVA testa in različnih varianc ne bo enaka oz. blizu vrednosti $0.05$. Zaradi kršenja predpostavk bomo prevečkrat oz. premalokrat zavračali ničelno hipotezo, ko ta drži.

```{r}
valAnal = aggregate(pVal~ n + var + method , data = resLong,
                    function(x)mean(x<0.05))

valAnal$n<-as.factor(valAnal$n)
ggplot(valAnal, aes(y=pVal, col=method, group=method, x=n))+
  geom_point()+geom_smooth(se=F)+
  geom_hline(yintercept = 0.05)+
  facet_wrap(vars(var)) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

Res smo potrdili zgornje predvidevanje. V primeru različnih varianc klasični ANOVA test prevečkrat zavrne ničelno hipotezo. Ko pa je varianca v vseh treh skupinah enaka $1$, so vrednosti dokaj podobne. 

# Moč testa

Glede na moč testa lahko primerjamo vse tri teste le v primeru enkaih varianc. V preostalih primerih klasični ANOVA test ni veljaven zato bomo primerjali le preostala dva.

Najprej primerjajmo med seboj teste v primeru enakih varinac.


```{r simulacije moc testa enake varinace}
st_ponovitev = 2000
velikost = c(15, 40, 60, 100, 200, 500)
povp = c("0,0.5,0", "0,-0.5,0.5")

settings = expand.grid(i=1:st_ponovitev, n = velikost, povp = povp,
                       var = "1,1,1")

if(file.exists("moc_enake.RDS")){
  res_p<-readRDS("moc_enake.RDS")
} else {
  res_p<-cbind(settings, pANOVA=NA, pANOVA_2=NA, pMETHOD3=NA)
  for(row in 1:nrow(settings)){
    velikost = settings$n[row]
    var_skupaj = as.numeric(strsplit(as.character(settings$var[row]),",")[[1]])
    sd1 = sqrt(var_skupaj[1])
    sd2 = sqrt(var_skupaj[2])
    sd3 = sqrt(var_skupaj[3])
    povp_skupaj = as.numeric(strsplit(as.character(settings$povp[row]),",")[[1]])
    povp1 = povp_skupaj[1]
    povp2 = povp_skupaj[2]
    povp3 = povp_skupaj[3]
    
    x<-c(rnorm(velikost, povp1, sd1),
         rnorm(velikost, povp2, sd2),
         rnorm(velikost, povp3, sd3))
    gr<-factor(rep(1:3, times=c(velikost,velikost,velikost)))
    
    res_p$pANOVA[row] = summary(aov(x~gr))[[1]][["Pr(>F)"]][1]
    res_p$pANOVA_2[row] = oneway.test(x~gr, var.equal = FALSE)$p.value
    
    p_test_enak_V = leveneTest(x~gr)$`Pr(>F)`[1]
    if(p_test_enak_V > 0.05){
      res_p$pMETHOD3[row] = summary(aov(x~gr))[[1]][["Pr(>F)"]][1]
    } else {
      res_p$pMETHOD3[row] = oneway.test(x~gr, var.equal = FALSE)$p.value
    }
  }
  saveRDS(object = res_p, file="moc_enake.RDS")
}

```


```{r risanje moci enake var}
# dava v format long
resLong_P = pivot_longer(res_p, cols=matches("^p[AM]"), values_to = "power",
                       names_to = "method", names_prefix = "p")

# testirava za enakomerno porazdelitev z Anderson-Darling testom
valAnal_P = aggregate(power ~ n + method + povp, data = resLong_P,
                    function(x)mean(x<0.05))

valAnal_P$n<-as.factor(valAnal_P$n)
ggplot(valAnal_P, aes(y=power, col=method, group=method, x=n))+
  geom_point()+geom_line()+
  geom_hline(yintercept = 0.05)+
  facet_wrap(vars(povp))+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

Nato pa še primer, ko so variance različne. \
(vrstice predstavljajo varinaco skupin, stolpci pa povprečje posamezne skupine)

```{r simulacije moc testa razlicne varinace}
st_ponovitev = 2000
velikost = c(15, 40, 60, 100, 200, 500)
povp = c("0,1,0", "0,-1,1")

settings = expand.grid(i=1:st_ponovitev, n = velikost, povp = povp,
                       var = c("1,10,1", "1,5,10"))

if(file.exists("moc_razlicne.RDS")){
  res_p<-readRDS("moc_razlicne.RDS")
} else {
  res_p<-cbind(settings, pANOVA_2=NA, pMETHOD3=NA)
  for(row in 1:nrow(settings)){
    velikost = settings$n[row]
    var_skupaj = as.numeric(strsplit(as.character(settings$var[row]),",")[[1]])
    sd1 = sqrt(var_skupaj[1])
    sd2 = sqrt(var_skupaj[2])
    sd3 = sqrt(var_skupaj[3])
    povp_skupaj = as.numeric(strsplit(as.character(settings$povp[row]),",")[[1]])
    povp1 = povp_skupaj[1]
    povp2 = povp_skupaj[2]
    povp3 = povp_skupaj[3]
    
    x<-c(rnorm(velikost, povp1, sd1),
         rnorm(velikost, povp2, sd2),
         rnorm(velikost, povp3, sd3))
    gr<-factor(rep(1:3, times=c(velikost,velikost,velikost)))
    
    # res_p$pANOVA[row] = summary(aov(x~gr))[[1]][["Pr(>F)"]][1]
    res_p$pANOVA_2[row] = oneway.test(x~gr, var.equal = FALSE)$p.value
    
    p_test_enak_V = leveneTest(x~gr)$`Pr(>F)`[1]
    if(p_test_enak_V > 0.05){
      res_p$pMETHOD3[row] = summary(aov(x~gr))[[1]][["Pr(>F)"]][1]
    } else {
      res_p$pMETHOD3[row] = oneway.test(x~gr, var.equal = FALSE)$p.value
    }
  }
  saveRDS(object = res_p, file="moc_razlicne.RDS")
}

```


```{r risanje moci razlicne var}
# dava v format long
resLong_P = pivot_longer(res_p, cols=matches("^p[AM]"), values_to = "power",
                       names_to = "method", names_prefix = "p")

# testirava za enakomerno porazdelitev z Anderson-Darling testom
valAnal_P = aggregate(power ~ n + var + method + povp, data = resLong_P,
                    function(x)mean(x<0.05))

valAnal_P$n<-as.factor(valAnal_P$n)
ggplot(valAnal_P, aes(y=power, col=method, group=method, x=n))+
  geom_point()+geom_line()+
  geom_hline(yintercept = 0.05)+
  facet_grid(var~povp)+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```
